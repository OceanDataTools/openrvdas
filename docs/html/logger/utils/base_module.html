<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.utils.base_module API documentation</title>
<meta name="description" content="The biggest thing that this abstract parent class does is help with (optional)
type checking of the child class&#39; inputs and outputs. In the past an â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.utils.base_module</code></h1>
</header>
<section id="section-intro">
<p>The biggest thing that this abstract parent class does is help with (optional)
type checking of the child class' inputs and outputs. In the past an explicit,
but very awkward, form of type checking was used, with child classes passing the
Transform class a list of input_format and output_format specifications.</p>
<p>That is now deprecated in favor of using Python's type hints. Type hints should be
specified for the child class' read(), transform() or write() method. Then the method can
call self.can_process_record(record) to see whether it's one of the input types it
can handle, and/or check_result to see if the output is as expected. If not, it can
"return self.digest_record(record) to have the parent class try to deal with it:</p>
<p>E.g.:
def transform(self, record: Union[int, str, float]):
if not self.can_process_record(record):
# inherited from BaseModule()
return self.digest_record(record)
# inherited from BaseModule()
return str(record) + '+'</p>
<p>If no type hints are specified, can_process_record() will return True for all
records <em>except</em> those of type "None" or "list". The logic is that digest_record()
will return a None when given a None, and when given a list, will iteratively
apply the transform to every element of the list and return the resulting list.</p>
<p>Note that the child class can explicitly call super().<strong>init</strong>(quiet=True) or such
to initialize the type checking and set its debugging level. If it is not explicitly
initialized, it will be done implicitly the first time can_process_record() or
digest_record() are called, but with the default of quiet=False.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
&#34;&#34;&#34;
The biggest thing that this abstract parent class does is help with (optional)
type checking of the child class&#39; inputs and outputs. In the past an explicit,
but very awkward, form of type checking was used, with child classes passing the
Transform class a list of input_format and output_format specifications.

That is now deprecated in favor of using Python&#39;s type hints. Type hints should be
specified for the child class&#39; read(), transform() or write() method. Then the method can
call self.can_process_record(record) to see whether it&#39;s one of the input types it
can handle, and/or check_result to see if the output is as expected. If not, it can
&#34;return self.digest_record(record) to have the parent class try to deal with it:

E.g.:
     def transform(self, record: Union[int, str, float]):
        if not self.can_process_record(record):  # inherited from BaseModule()
            return self.digest_record(record)  # inherited from BaseModule()
         return str(record) + &#39;+&#39;

If no type hints are specified, can_process_record() will return True for all
records *except* those of type &#34;None&#34; or &#34;list&#34;. The logic is that digest_record()
will return a None when given a None, and when given a list, will iteratively
apply the transform to every element of the list and return the resulting list.

Note that the child class can explicitly call super().__init__(quiet=True) or such
to initialize the type checking and set its debugging level. If it is not explicitly
initialized, it will be done implicitly the first time can_process_record() or
digest_record() are called, but with the default of quiet=False.
&#34;&#34;&#34;
import inspect
import logging
import sys
from typing import get_args

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.utils.das_record import DASRecord  # noqa E402


########################################
def get_method_type_hints(method):
    &#34;&#34;&#34;
    When passed a method via something like

        get_method_type_hints(self.__class__.transform)

    return a dict of the method&#39;s type hints for the arguments
    and return value. E.g., if transform() is defined as:

        def transform(self, record: int|float) -&gt; str:

    will return

        {&#39;return&#39;: (&lt;class &#39;str&#39;&gt;),
         &#39;record&#39;: (&lt;class &#39;int&#39;&gt;, &lt;class &#39;float&#39;&gt;)}

    The point of this routine is to allow Transform and Writer to sanity
    check their inputs.
    &#34;&#34;&#34;
    method_args = inspect.getfullargspec(method).annotations
    method_types = {k: tuple([value])
                    if isinstance(value, type)
                    else tuple(get_args(value))
                    for k, value in method_args.items()
                    }
    return method_types


################################################################################
class BaseModule:
    &#34;&#34;&#34;
    Base class for OpenRVDAS Readers, Transforms and Writers.

    Implements method for checking whether a received record is in a format
    that the derived class can process, and also a method for splitting a
    list of records into its elements and calling subclass transform() on them.
    &#34;&#34;&#34;
    ############################
    def __init__(self, quiet=False, input_format=None, output_format=None):
        self._initialize_type_hints(quiet=quiet)

        if input_format or output_format:
            logging.warning(f&#39;Code warning: {self.__class__.__name__} use of &#39;
                            f&#39;&#34;input_format&#34; or &#34;output_format&#34; is deprecated. &#39;
                            f&#39;Please see Transform code documentation.&#39;)

    ############################
    def _initialize_type_hints(self, module_type, module_method, quiet=False):
        &#34;&#34;&#34;We should only get called from the _initialize_type_hints method of
        Reader/Transform/Writer subclasses, which should fill in all parameters.

        Retrieve any type hints for child read()/transform()/write() method so we
        can check whether the type of record we&#39;ve received can be parsed
        natively or not.&#34;&#34;&#34;
        self.module_type = module_type
        self.module_method = module_method
        self.quiet = quiet

        # We make stupid assumption that the input variable is called &#39;record&#39;
        method_type_hints = get_method_type_hints(self.module_method)
        self.input_types = method_type_hints.get(&#39;record&#39;)
        self.return_types = method_type_hints.get(&#39;return&#39;)

        # logging.warning(f&#39;input_types: {self.input_types}&#39;)
        # logging.warning(f&#39;return_types: {self.return_types}&#39;)

        # Other things we&#39;d want to make sure are defined.
        self.class_name = self.__class__.__name__
        self.initialized = True

    ############################
    def can_process_record(self, record):
        &#34;&#34;&#34; Is this record in a format that the transform or writer can handle?

        - If there are type hints: True if type of record is in type hints.
        - If there are no type hints: False if None or list, otherwise True.

        The logic is that if there are no type hints and we see False or
        a list, we expect digest_record() to be called to deal with it.&#34;&#34;&#34;

        try:  # if we&#39;ve not been initialized with type hints, initialize now
            self.initialized or True
        except AttributeError:
            # This will call the subclass initialization, e.g.
            # Transform._initialize_type_hints(), which will in turn call
            # OpenRVDASModule._initialize_type_hints()
            self._initialize_type_hints()

        # Special case: we want to turn empty str records into None. By saying
        # no, record should get punted to digest_record(), which will do the
        # right thing.
        if isinstance(record, str) and not len(record):
            return False

        if self.input_types:
            return isinstance(record, self.input_types)

        # If not type hints, make some judgment calls. Say &#34;no&#34; to None
        # and to lists, because we&#39;ll expect that answer to trigger a
        # call to digest_record(), which will handle them.
        if record is None or isinstance(record, list):
            return False
        return True

    ############################
    def digest_record(self, record):
        &#34;&#34;&#34; Try to digest record down into a format that the method can
        handle. Typically that will mean that we&#39;ve been handed a list of
        records that we need to break into individual records.&#34;&#34;&#34;

        try:  # if we&#39;ve not been initialized with type hints, initialize now
            self.initialized or True
        except AttributeError:
            self._initialize_type_hints()

        # Go through our litany of things that reduce to None
        if record is None:
            return None

        if isinstance(record, str) and not len(record):
            return None

        # If it&#39;s a type the method can handle directly (though, if so,
        # why were we called?!?
        if self.can_process_record(record) and not self.quiet:
            logging.warning(f&#39;{self.class_name}: digest_record() called unnecessarily.&#39;)
            logging.warning(f&#39;Can process {self.input_types}; received {type(record)}: {record}&#39;)
            return self.module_method(record)

        # We know how to deal with it if it&#39;s a list: Apply to components,
        # stripping out any None&#39;s
        if isinstance(record, list):
            result = [self.module_method(self, r) for r in record if r is not None]
            return [r for r in result if r is not None]  # remove Nones

        # Is record a number we can convert to a string?
        if str in self.input_types and isinstance(record, (int, float)):
            return str(record)

        # If it&#39;s a DASRecord, serialize it as JSON
        if str in self.input_types and isinstance(record, DASRecord):
            return record.as_json()

        # If we don&#39;t know how to deal with it
        if not self.quiet:
            logging.warning(f&#39;Unable to convert record to format &#34;{self.class_name}&#34; can process&#39;)
            logging.warning(f&#39;Must be instance or list of {self.input_types}&#39;)
            logging.warning(f&#39;Received {type(record)}: {record}&#39;)
        return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="logger.utils.base_module.get_method_type_hints"><code class="name flex">
<span>def <span class="ident">get_method_type_hints</span></span>(<span>method)</span>
</code></dt>
<dd>
<div class="desc"><p>When passed a method via something like</p>
<pre><code>get_method_type_hints(self.__class__.transform)
</code></pre>
<p>return a dict of the method's type hints for the arguments
and return value. E.g., if transform() is defined as:</p>
<pre><code>def transform(self, record: int|float) -&gt; str:
</code></pre>
<p>will return</p>
<pre><code>{'return': (&lt;class 'str'&gt;),
 'record': (&lt;class 'int'&gt;, &lt;class 'float'&gt;)}
</code></pre>
<p>The point of this routine is to allow Transform and Writer to sanity
check their inputs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method_type_hints(method):
    &#34;&#34;&#34;
    When passed a method via something like

        get_method_type_hints(self.__class__.transform)

    return a dict of the method&#39;s type hints for the arguments
    and return value. E.g., if transform() is defined as:

        def transform(self, record: int|float) -&gt; str:

    will return

        {&#39;return&#39;: (&lt;class &#39;str&#39;&gt;),
         &#39;record&#39;: (&lt;class &#39;int&#39;&gt;, &lt;class &#39;float&#39;&gt;)}

    The point of this routine is to allow Transform and Writer to sanity
    check their inputs.
    &#34;&#34;&#34;
    method_args = inspect.getfullargspec(method).annotations
    method_types = {k: tuple([value])
                    if isinstance(value, type)
                    else tuple(get_args(value))
                    for k, value in method_args.items()
                    }
    return method_types</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.utils.base_module.BaseModule"><code class="flex name class">
<span>class <span class="ident">BaseModule</span></span>
<span>(</span><span>quiet=False, input_format=None, output_format=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for OpenRVDAS Readers, Transforms and Writers.</p>
<p>Implements method for checking whether a received record is in a format
that the derived class can process, and also a method for splitting a
list of records into its elements and calling subclass transform() on them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseModule:
    &#34;&#34;&#34;
    Base class for OpenRVDAS Readers, Transforms and Writers.

    Implements method for checking whether a received record is in a format
    that the derived class can process, and also a method for splitting a
    list of records into its elements and calling subclass transform() on them.
    &#34;&#34;&#34;
    ############################
    def __init__(self, quiet=False, input_format=None, output_format=None):
        self._initialize_type_hints(quiet=quiet)

        if input_format or output_format:
            logging.warning(f&#39;Code warning: {self.__class__.__name__} use of &#39;
                            f&#39;&#34;input_format&#34; or &#34;output_format&#34; is deprecated. &#39;
                            f&#39;Please see Transform code documentation.&#39;)

    ############################
    def _initialize_type_hints(self, module_type, module_method, quiet=False):
        &#34;&#34;&#34;We should only get called from the _initialize_type_hints method of
        Reader/Transform/Writer subclasses, which should fill in all parameters.

        Retrieve any type hints for child read()/transform()/write() method so we
        can check whether the type of record we&#39;ve received can be parsed
        natively or not.&#34;&#34;&#34;
        self.module_type = module_type
        self.module_method = module_method
        self.quiet = quiet

        # We make stupid assumption that the input variable is called &#39;record&#39;
        method_type_hints = get_method_type_hints(self.module_method)
        self.input_types = method_type_hints.get(&#39;record&#39;)
        self.return_types = method_type_hints.get(&#39;return&#39;)

        # logging.warning(f&#39;input_types: {self.input_types}&#39;)
        # logging.warning(f&#39;return_types: {self.return_types}&#39;)

        # Other things we&#39;d want to make sure are defined.
        self.class_name = self.__class__.__name__
        self.initialized = True

    ############################
    def can_process_record(self, record):
        &#34;&#34;&#34; Is this record in a format that the transform or writer can handle?

        - If there are type hints: True if type of record is in type hints.
        - If there are no type hints: False if None or list, otherwise True.

        The logic is that if there are no type hints and we see False or
        a list, we expect digest_record() to be called to deal with it.&#34;&#34;&#34;

        try:  # if we&#39;ve not been initialized with type hints, initialize now
            self.initialized or True
        except AttributeError:
            # This will call the subclass initialization, e.g.
            # Transform._initialize_type_hints(), which will in turn call
            # OpenRVDASModule._initialize_type_hints()
            self._initialize_type_hints()

        # Special case: we want to turn empty str records into None. By saying
        # no, record should get punted to digest_record(), which will do the
        # right thing.
        if isinstance(record, str) and not len(record):
            return False

        if self.input_types:
            return isinstance(record, self.input_types)

        # If not type hints, make some judgment calls. Say &#34;no&#34; to None
        # and to lists, because we&#39;ll expect that answer to trigger a
        # call to digest_record(), which will handle them.
        if record is None or isinstance(record, list):
            return False
        return True

    ############################
    def digest_record(self, record):
        &#34;&#34;&#34; Try to digest record down into a format that the method can
        handle. Typically that will mean that we&#39;ve been handed a list of
        records that we need to break into individual records.&#34;&#34;&#34;

        try:  # if we&#39;ve not been initialized with type hints, initialize now
            self.initialized or True
        except AttributeError:
            self._initialize_type_hints()

        # Go through our litany of things that reduce to None
        if record is None:
            return None

        if isinstance(record, str) and not len(record):
            return None

        # If it&#39;s a type the method can handle directly (though, if so,
        # why were we called?!?
        if self.can_process_record(record) and not self.quiet:
            logging.warning(f&#39;{self.class_name}: digest_record() called unnecessarily.&#39;)
            logging.warning(f&#39;Can process {self.input_types}; received {type(record)}: {record}&#39;)
            return self.module_method(record)

        # We know how to deal with it if it&#39;s a list: Apply to components,
        # stripping out any None&#39;s
        if isinstance(record, list):
            result = [self.module_method(self, r) for r in record if r is not None]
            return [r for r in result if r is not None]  # remove Nones

        # Is record a number we can convert to a string?
        if str in self.input_types and isinstance(record, (int, float)):
            return str(record)

        # If it&#39;s a DASRecord, serialize it as JSON
        if str in self.input_types and isinstance(record, DASRecord):
            return record.as_json()

        # If we don&#39;t know how to deal with it
        if not self.quiet:
            logging.warning(f&#39;Unable to convert record to format &#34;{self.class_name}&#34; can process&#39;)
            logging.warning(f&#39;Must be instance or list of {self.input_types}&#39;)
            logging.warning(f&#39;Received {type(record)}: {record}&#39;)
        return None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="logger.transforms.transform.Transform" href="../transforms/transform.html#logger.transforms.transform.Transform">Transform</a></li>
<li><a title="logger.writers.writer.Writer" href="../writers/writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.utils.base_module.BaseModule.can_process_record"><code class="name flex">
<span>def <span class="ident">can_process_record</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Is this record in a format that the transform or writer can handle?</p>
<ul>
<li>If there are type hints: True if type of record is in type hints.</li>
<li>If there are no type hints: False if None or list, otherwise True.</li>
</ul>
<p>The logic is that if there are no type hints and we see False or
a list, we expect digest_record() to be called to deal with it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_process_record(self, record):
    &#34;&#34;&#34; Is this record in a format that the transform or writer can handle?

    - If there are type hints: True if type of record is in type hints.
    - If there are no type hints: False if None or list, otherwise True.

    The logic is that if there are no type hints and we see False or
    a list, we expect digest_record() to be called to deal with it.&#34;&#34;&#34;

    try:  # if we&#39;ve not been initialized with type hints, initialize now
        self.initialized or True
    except AttributeError:
        # This will call the subclass initialization, e.g.
        # Transform._initialize_type_hints(), which will in turn call
        # OpenRVDASModule._initialize_type_hints()
        self._initialize_type_hints()

    # Special case: we want to turn empty str records into None. By saying
    # no, record should get punted to digest_record(), which will do the
    # right thing.
    if isinstance(record, str) and not len(record):
        return False

    if self.input_types:
        return isinstance(record, self.input_types)

    # If not type hints, make some judgment calls. Say &#34;no&#34; to None
    # and to lists, because we&#39;ll expect that answer to trigger a
    # call to digest_record(), which will handle them.
    if record is None or isinstance(record, list):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="logger.utils.base_module.BaseModule.digest_record"><code class="name flex">
<span>def <span class="ident">digest_record</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Try to digest record down into a format that the method can
handle. Typically that will mean that we've been handed a list of
records that we need to break into individual records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def digest_record(self, record):
    &#34;&#34;&#34; Try to digest record down into a format that the method can
    handle. Typically that will mean that we&#39;ve been handed a list of
    records that we need to break into individual records.&#34;&#34;&#34;

    try:  # if we&#39;ve not been initialized with type hints, initialize now
        self.initialized or True
    except AttributeError:
        self._initialize_type_hints()

    # Go through our litany of things that reduce to None
    if record is None:
        return None

    if isinstance(record, str) and not len(record):
        return None

    # If it&#39;s a type the method can handle directly (though, if so,
    # why were we called?!?
    if self.can_process_record(record) and not self.quiet:
        logging.warning(f&#39;{self.class_name}: digest_record() called unnecessarily.&#39;)
        logging.warning(f&#39;Can process {self.input_types}; received {type(record)}: {record}&#39;)
        return self.module_method(record)

    # We know how to deal with it if it&#39;s a list: Apply to components,
    # stripping out any None&#39;s
    if isinstance(record, list):
        result = [self.module_method(self, r) for r in record if r is not None]
        return [r for r in result if r is not None]  # remove Nones

    # Is record a number we can convert to a string?
    if str in self.input_types and isinstance(record, (int, float)):
        return str(record)

    # If it&#39;s a DASRecord, serialize it as JSON
    if str in self.input_types and isinstance(record, DASRecord):
        return record.as_json()

    # If we don&#39;t know how to deal with it
    if not self.quiet:
        logging.warning(f&#39;Unable to convert record to format &#34;{self.class_name}&#34; can process&#39;)
        logging.warning(f&#39;Must be instance or list of {self.input_types}&#39;)
        logging.warning(f&#39;Received {type(record)}: {record}&#39;)
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.utils" href="index.html">logger.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="logger.utils.base_module.get_method_type_hints" href="#logger.utils.base_module.get_method_type_hints">get_method_type_hints</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.utils.base_module.BaseModule" href="#logger.utils.base_module.BaseModule">BaseModule</a></code></h4>
<ul class="">
<li><code><a title="logger.utils.base_module.BaseModule.can_process_record" href="#logger.utils.base_module.BaseModule.can_process_record">can_process_record</a></code></li>
<li><code><a title="logger.utils.base_module.BaseModule.digest_record" href="#logger.utils.base_module.BaseModule.digest_record">digest_record</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>