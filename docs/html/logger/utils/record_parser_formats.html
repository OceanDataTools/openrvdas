<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.utils.record_parser_formats API documentation</title>
<meta name="description" content="Custom format definitions for RecordParser â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.utils.record_parser_formats</code></h1>
</header>
<section id="section-intro">
<p>Custom format definitions for RecordParser.</p>
<p>To use, import the 'extra_format_types' dict and pass to the parser:</p>
<p>import parse
from logger.utils.record_parser_formats import extra_format_types</p>
<p>pattern = parse.compile(format=record_format, extra_types=extra_format_types)
parsed_values = pattern.parse(record)</p>
<h1 id="why-we-have-this">Why We Have This</h1>
<p>We want to expand the default repertoire of the parse() function to be
able to handle ints/floats/strings that <em>might</em> be omitted. To do
that, we define some additional named types for it that we can use in
format definitions.</p>
<p>These might be used, for example, in the following pattern where we
might have either, both or neither of speed in knots and/or km/hour.</p>
<p>"{SpeedKt:of},N,{SpeedKm:of},K"</p>
<p>The recognized format types we add are:
od
= optional integer
of
= optional generalized float
og
= optional generalized number - also handles '#VALUE!' as None
ow
= optional sequence of letters, numbers, underscores
os
= optional sequence of any characters - will match everything on line</p>
<p>nlat = NMEA-formatted latitude or longitude, converted to decimal degrees</p>
<p>nc = any ASCII text that is not a comma
ns = any ASCII text that is not an asterisk ("star")</p>
<p>See 'Custom Type Conversions' in <a href="https://pypi.org/project/parse/">https://pypi.org/project/parse/</a> for a
discussion of how format types work.</p>
<p>TODO: allow device_type definitions to hand in their own format types.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;Custom format definitions for RecordParser.

To use, import the &#39;extra_format_types&#39; dict and pass to the parser:

import parse
from logger.utils.record_parser_formats import extra_format_types

pattern = parse.compile(format=record_format, extra_types=extra_format_types)
parsed_values = pattern.parse(record)

# Why We Have This

We want to expand the default repertoire of the parse() function to be
able to handle ints/floats/strings that *might* be omitted. To do
that, we define some additional named types for it that we can use in
format definitions.

These might be used, for example, in the following pattern where we
might have either, both or neither of speed in knots and/or km/hour.

  &#34;{SpeedKt:of},N,{SpeedKm:of},K&#34;

The recognized format types we add are:
  od   = optional integer
  of   = optional generalized float
  og   = optional generalized number - also handles &#39;#VALUE!&#39; as None
  ow   = optional sequence of letters, numbers, underscores
  os   = optional sequence of any characters - will match everything on line

  nlat = NMEA-formatted latitude or longitude, converted to decimal degrees

  nc = any ASCII text that is not a comma
  ns = any ASCII text that is not an asterisk (&#34;star&#34;)

See &#39;Custom Type Conversions&#39; in https://pypi.org/project/parse/ for a
discussion of how format types work.

TODO: allow device_type definitions to hand in their own format types.
&#34;&#34;&#34;
import logging


def optional_d(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; integer.&#34;&#34;&#34;
    if text:
        return int(text)
    else:
        return None


optional_d.pattern = r&#39;\s*[-+]?\d*&#39;


def optional_f(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; generalized float.&#34;&#34;&#34;
    if text:
        return float(text)
    else:
        return None


optional_f.pattern = r&#39;(\s*[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?|)&#39;


def optional_g(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; generalized number.&#34;&#34;&#34;
    if text == &#39;#VALUE!&#39;:
        return None
    if text:
        return float(text)
    else:
        return None


optional_g.pattern = r&#39;(#VALUE!|\s*[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?|\d*)&#39;


def optional_w(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; letters/numbers/underscore
    string.&#34;&#34;&#34;
    if text:
        return text
    else:
        return None


optional_w.pattern = r&#39;\w*&#39;


def optional_s(text):
    &#34;&#34;&#34;Method for parsing any sequence of zero or more characters. Will absorb
    everything in the string.
    &#34;&#34;&#34;
    if text:
        return text
    else:
        return &#39;&#39;


optional_s.pattern = r&#39;.*&#39;


def nmea_lat_lon(text):
    &#34;&#34;&#34;Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) and
    converting it into decimal degrees. Only handles the numeric part, not
    any E/W or N/S component.&#34;&#34;&#34;
    if text:
        nmea_value = float(text)
        normalized_value = nmea_value / 100
        degrees = int(normalized_value)
        if abs(degrees) &gt;= 180.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        fractional_degrees = (normalized_value - degrees) / 0.60
        if abs(fractional_degrees) &gt;= 1.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        return degrees + fractional_degrees
    else:
        return None


nmea_lat_lon.pattern = r&#39;(\s*[-]?(\d+(\.\d*)?|\.\d+)?|)&#39;


def nmea_lat_lon_dir(text):
    &#34;&#34;&#34;Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) along
    with the hemisphere (E/W/N/S) and converting it into signed decimal
    degrees. South and West are considered negative, North and East
    positive.
    &#34;&#34;&#34;
    if text:
        nmea_str, dir = text.split(&#39;,&#39;)
        nmea_value = float(nmea_str)
        normalized_value = nmea_value / 100
        degrees = int(normalized_value)
        if abs(degrees) &gt;= 180.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        fractional_degrees = (normalized_value - degrees) / 0.60
        if abs(fractional_degrees) &gt;= 1.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        decimal_degrees = degrees + fractional_degrees
        if dir in [&#39;W&#39;, &#39;S&#39;]:
            decimal_degrees = -decimal_degrees
        return decimal_degrees
    else:
        return None


nmea_lat_lon_dir.pattern = r&#39;(\s*(\d+(\.\d*)?|\.\d+),[NEWS]?|)&#39;


def not_comma(text):
    &#34;&#34;&#34;Method for parsing a string (or anything) between commas
    string.&#34;&#34;&#34;
    if text:
        return text
    else:
        return None


not_comma.pattern = r&#39;[^,]*&#39;


def not_star(text):
    &#34;&#34;&#34;Method for parsing a string (or anything) terminated by a &#34;*&#34;
    &#34;&#34;&#34;
    if text:
        return text
    else:
        return None


not_star.pattern = r&#39;[^\*]*&#39;


extra_format_types = dict(
    od=optional_d,
    of=optional_f,
    og=optional_g,
    ow=optional_w,
    os=optional_s,

    nlat=nmea_lat_lon,
    nlat_dir=nmea_lat_lon_dir,

    nc=not_comma,
    ns=not_star)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="logger.utils.record_parser_formats.nmea_lat_lon"><code class="name flex">
<span>def <span class="ident">nmea_lat_lon</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) and
converting it into decimal degrees. Only handles the numeric part, not
any E/W or N/S component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nmea_lat_lon(text):
    &#34;&#34;&#34;Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) and
    converting it into decimal degrees. Only handles the numeric part, not
    any E/W or N/S component.&#34;&#34;&#34;
    if text:
        nmea_value = float(text)
        normalized_value = nmea_value / 100
        degrees = int(normalized_value)
        if abs(degrees) &gt;= 180.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        fractional_degrees = (normalized_value - degrees) / 0.60
        if abs(fractional_degrees) &gt;= 1.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        return degrees + fractional_degrees
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.nmea_lat_lon_dir"><code class="name flex">
<span>def <span class="ident">nmea_lat_lon_dir</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) along
with the hemisphere (E/W/N/S) and converting it into signed decimal
degrees. South and West are considered negative, North and East
positive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nmea_lat_lon_dir(text):
    &#34;&#34;&#34;Method for parsing an NMEA latitude or longitude (DDDMM.MMMM) along
    with the hemisphere (E/W/N/S) and converting it into signed decimal
    degrees. South and West are considered negative, North and East
    positive.
    &#34;&#34;&#34;
    if text:
        nmea_str, dir = text.split(&#39;,&#39;)
        nmea_value = float(nmea_str)
        normalized_value = nmea_value / 100
        degrees = int(normalized_value)
        if abs(degrees) &gt;= 180.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        fractional_degrees = (normalized_value - degrees) / 0.60
        if abs(fractional_degrees) &gt;= 1.0:
            logging.warning(&#39;Improper NMEA-style latitude/longitude: &#34;%s&#34;&#39;, text)
            return None
        decimal_degrees = degrees + fractional_degrees
        if dir in [&#39;W&#39;, &#39;S&#39;]:
            decimal_degrees = -decimal_degrees
        return decimal_degrees
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.not_comma"><code class="name flex">
<span>def <span class="ident">not_comma</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing a string (or anything) between commas
string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_comma(text):
    &#34;&#34;&#34;Method for parsing a string (or anything) between commas
    string.&#34;&#34;&#34;
    if text:
        return text
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.not_star"><code class="name flex">
<span>def <span class="ident">not_star</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing a string (or anything) terminated by a "*"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def not_star(text):
    &#34;&#34;&#34;Method for parsing a string (or anything) terminated by a &#34;*&#34;
    &#34;&#34;&#34;
    if text:
        return text
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.optional_d"><code class="name flex">
<span>def <span class="ident">optional_d</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an 'optional' integer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional_d(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; integer.&#34;&#34;&#34;
    if text:
        return int(text)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.optional_f"><code class="name flex">
<span>def <span class="ident">optional_f</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an 'optional' generalized float.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional_f(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; generalized float.&#34;&#34;&#34;
    if text:
        return float(text)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.optional_g"><code class="name flex">
<span>def <span class="ident">optional_g</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an 'optional' generalized number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional_g(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; generalized number.&#34;&#34;&#34;
    if text == &#39;#VALUE!&#39;:
        return None
    if text:
        return float(text)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.optional_s"><code class="name flex">
<span>def <span class="ident">optional_s</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing any sequence of zero or more characters. Will absorb
everything in the string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional_s(text):
    &#34;&#34;&#34;Method for parsing any sequence of zero or more characters. Will absorb
    everything in the string.
    &#34;&#34;&#34;
    if text:
        return text
    else:
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="logger.utils.record_parser_formats.optional_w"><code class="name flex">
<span>def <span class="ident">optional_w</span></span>(<span>text)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for parsing an 'optional' letters/numbers/underscore
string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optional_w(text):
    &#34;&#34;&#34;Method for parsing an &#39;optional&#39; letters/numbers/underscore
    string.&#34;&#34;&#34;
    if text:
        return text
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#why-we-have-this">Why We Have This</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.utils" href="index.html">logger.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="logger.utils.record_parser_formats.nmea_lat_lon" href="#logger.utils.record_parser_formats.nmea_lat_lon">nmea_lat_lon</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.nmea_lat_lon_dir" href="#logger.utils.record_parser_formats.nmea_lat_lon_dir">nmea_lat_lon_dir</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.not_comma" href="#logger.utils.record_parser_formats.not_comma">not_comma</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.not_star" href="#logger.utils.record_parser_formats.not_star">not_star</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.optional_d" href="#logger.utils.record_parser_formats.optional_d">optional_d</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.optional_f" href="#logger.utils.record_parser_formats.optional_f">optional_f</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.optional_g" href="#logger.utils.record_parser_formats.optional_g">optional_g</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.optional_s" href="#logger.utils.record_parser_formats.optional_s">optional_s</a></code></li>
<li><code><a title="logger.utils.record_parser_formats.optional_w" href="#logger.utils.record_parser_formats.optional_w">optional_w</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>