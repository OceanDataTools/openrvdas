<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.writers.timeout_writer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.timeout_writer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import sys
import threading
import time

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.writers.writer import Writer  # noqa: E402


class TimeoutWriter(Writer):
    def __init__(self, writer, timeout, message=None, resume_message=None,
                 empty_is_okay=False, none_is_okay=False):
        &#34;&#34;&#34;Instantiated with a client Writer instance (such as a
        LogfileWriter), an interval, a timeout and optional
        message. Expects its write() method to be called at least every
        &#39;timeout&#39; seconds. If it isn&#39;t, call the client&#39;s write method
        with &#39;message&#39; to indicate that it has timed out. Once it receives
        a call to its write() method after timing out, call the client&#39;s
        write method with &#39;resume_message&#39; to indicate that it is no
        longer timed out.
        ```
        writer         A client writer instance

        timeout        Timeout interval in seconds

        message        Message to be returned if client reader fails to return
                       a record within the timeout interval

        resume_message Message to be returned when client returns a record after
                       having timed out

        empty_is_okay If True, receiving an empty record is sufficient to reset
                      the timer.
        none_is_okay  If True, receiving a &#39;None&#39; record is sufficient to reset
                        the timer.
        ```
        Sample config that echos stdin and issues timeouts if no input for 5 secs:
        ```
          readers:
          - class: TextFileReader
          transforms:
          - class: TimestampTransform
          writers:
          - class: TextFileWriter
          - class: TimeoutWriter
            kwargs:
              writer:
                class: TextFileWriter
              timeout: 5
              message: No message received for 5 seconds
              resume_message: Okay, got another message
        ```
        &#34;&#34;&#34;
        self.writer = writer
        self.timeout = timeout
        self.message = message or (&#39;Timeout: no %s record received in %d seconds&#39;
                                   % (writer, timeout))
        self.resume_message = resume_message or (&#39;Timeout: %s record received&#39;
                                                 % writer)
        self.empty_is_okay = empty_is_okay
        self.none_is_okay = none_is_okay

        # When we got our last record (or were instantiated)
        self.last_record = time.time()

        # Keep track of whether we&#39;re currently timed out or not
        self.timed_out = False

        # Protect self.last_record and self.timed_out
        self.timeout_lock = threading.Lock()

        # To let us cleanly exit _timeout_thread
        self.quit_signaled = False

        # Start the timeout loop in a separate thread
        self.timeout_thread = threading.Thread(target=self._timeout_thread,
                                               name=&#39;timeout_thread&#39;, daemon=True)
        self.timeout_thread.start()

    ############################
    def __del__(self):
        self.quit()

    ############################
    def _timeout_thread(self):
        &#34;&#34;&#34;Call client write() if we have/haven&#39;t had our own write() called
        within the alloted time.
        &#34;&#34;&#34;
        while not self.quit_signaled:
            now = time.time()
            with self.timeout_lock:
                time_to_sleep = self.timeout - (now - self.last_record)

                # If we&#39;re overdue for a record...
                if time_to_sleep &lt; 0:
                    # If we weren&#39;t already timed out, we are now. Send message.
                    if not self.timed_out:
                        self.timed_out = True
                        self.writer.write(self.message)

                    # Check again in timeout seconds
                    time_to_sleep = self.timeout

            # Whether or not we&#39;re timed out, snooze until we expect our
            # next timeout.
            time.sleep(time_to_sleep)

    ############################
    def quit(self):
        self.quit_signaled = True

    ############################
    def write(self, record):
        &#34;&#34;&#34;Register that we&#39;ve had a write() call; reset timeout timer.&#34;&#34;&#34;
        if record is None and not self.none_is_okay:
            return
        if not record and not self.empty_is_okay:
            return

        # If here, we got a bona fide record. Reset our timer.
        with self.timeout_lock:
            if self.timed_out:
                self.timed_out = False
                self.writer.write(self.resume_message)
            self.last_record = time.time()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.timeout_writer.TimeoutWriter"><code class="flex name class">
<span>class <span class="ident">TimeoutWriter</span></span>
<span>(</span><span>writer, timeout, message=None, resume_message=None, empty_is_okay=False, none_is_okay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class Writer about which we know nothing else. By default the
input format is Unknown unless overridden.</p>
<p>Instantiated with a client Writer instance (such as a
LogfileWriter), an interval, a timeout and optional
message. Expects its write() method to be called at least every
'timeout' seconds. If it isn't, call the client's write method
with 'message' to indicate that it has timed out. Once it receives
a call to its write() method after timing out, call the client's
write method with 'resume_message' to indicate that it is no
longer timed out.</p>
<pre><code>writer         A client writer instance

timeout        Timeout interval in seconds

message        Message to be returned if client reader fails to return
               a record within the timeout interval

resume_message Message to be returned when client returns a record after
               having timed out

empty_is_okay If True, receiving an empty record is sufficient to reset
              the timer.
none_is_okay  If True, receiving a 'None' record is sufficient to reset
                the timer.
</code></pre>
<p>Sample config that echos stdin and issues timeouts if no input for 5 secs:</p>
<pre><code>  readers:
  - class: TextFileReader
  transforms:
  - class: TimestampTransform
  writers:
  - class: TextFileWriter
  - class: TimeoutWriter
    kwargs:
      writer:
        class: TextFileWriter
      timeout: 5
      message: No message received for 5 seconds
      resume_message: Okay, got another message
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeoutWriter(Writer):
    def __init__(self, writer, timeout, message=None, resume_message=None,
                 empty_is_okay=False, none_is_okay=False):
        &#34;&#34;&#34;Instantiated with a client Writer instance (such as a
        LogfileWriter), an interval, a timeout and optional
        message. Expects its write() method to be called at least every
        &#39;timeout&#39; seconds. If it isn&#39;t, call the client&#39;s write method
        with &#39;message&#39; to indicate that it has timed out. Once it receives
        a call to its write() method after timing out, call the client&#39;s
        write method with &#39;resume_message&#39; to indicate that it is no
        longer timed out.
        ```
        writer         A client writer instance

        timeout        Timeout interval in seconds

        message        Message to be returned if client reader fails to return
                       a record within the timeout interval

        resume_message Message to be returned when client returns a record after
                       having timed out

        empty_is_okay If True, receiving an empty record is sufficient to reset
                      the timer.
        none_is_okay  If True, receiving a &#39;None&#39; record is sufficient to reset
                        the timer.
        ```
        Sample config that echos stdin and issues timeouts if no input for 5 secs:
        ```
          readers:
          - class: TextFileReader
          transforms:
          - class: TimestampTransform
          writers:
          - class: TextFileWriter
          - class: TimeoutWriter
            kwargs:
              writer:
                class: TextFileWriter
              timeout: 5
              message: No message received for 5 seconds
              resume_message: Okay, got another message
        ```
        &#34;&#34;&#34;
        self.writer = writer
        self.timeout = timeout
        self.message = message or (&#39;Timeout: no %s record received in %d seconds&#39;
                                   % (writer, timeout))
        self.resume_message = resume_message or (&#39;Timeout: %s record received&#39;
                                                 % writer)
        self.empty_is_okay = empty_is_okay
        self.none_is_okay = none_is_okay

        # When we got our last record (or were instantiated)
        self.last_record = time.time()

        # Keep track of whether we&#39;re currently timed out or not
        self.timed_out = False

        # Protect self.last_record and self.timed_out
        self.timeout_lock = threading.Lock()

        # To let us cleanly exit _timeout_thread
        self.quit_signaled = False

        # Start the timeout loop in a separate thread
        self.timeout_thread = threading.Thread(target=self._timeout_thread,
                                               name=&#39;timeout_thread&#39;, daemon=True)
        self.timeout_thread.start()

    ############################
    def __del__(self):
        self.quit()

    ############################
    def _timeout_thread(self):
        &#34;&#34;&#34;Call client write() if we have/haven&#39;t had our own write() called
        within the alloted time.
        &#34;&#34;&#34;
        while not self.quit_signaled:
            now = time.time()
            with self.timeout_lock:
                time_to_sleep = self.timeout - (now - self.last_record)

                # If we&#39;re overdue for a record...
                if time_to_sleep &lt; 0:
                    # If we weren&#39;t already timed out, we are now. Send message.
                    if not self.timed_out:
                        self.timed_out = True
                        self.writer.write(self.message)

                    # Check again in timeout seconds
                    time_to_sleep = self.timeout

            # Whether or not we&#39;re timed out, snooze until we expect our
            # next timeout.
            time.sleep(time_to_sleep)

    ############################
    def quit(self):
        self.quit_signaled = True

    ############################
    def write(self, record):
        &#34;&#34;&#34;Register that we&#39;ve had a write() call; reset timeout timer.&#34;&#34;&#34;
        if record is None and not self.none_is_okay:
            return
        if not record and not self.empty_is_okay:
            return

        # If here, we got a bona fide record. Reset our timer.
        with self.timeout_lock:
            if self.timed_out:
                self.timed_out = False
                self.writer.write(self.resume_message)
            self.last_record = time.time()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.writers.timeout_writer.TimeoutWriter.quit"><code class="name flex">
<span>def <span class="ident">quit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quit(self):
    self.quit_signaled = True</code></pre>
</details>
</dd>
<dt id="logger.writers.timeout_writer.TimeoutWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Register that we've had a write() call; reset timeout timer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, record):
    &#34;&#34;&#34;Register that we&#39;ve had a write() call; reset timeout timer.&#34;&#34;&#34;
    if record is None and not self.none_is_okay:
        return
    if not record and not self.empty_is_okay:
        return

    # If here, we got a bona fide record. Reset our timer.
    with self.timeout_lock:
        if self.timed_out:
            self.timed_out = False
            self.writer.write(self.resume_message)
        self.last_record = time.time()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.writer.Writer.can_accept" href="writer.html#logger.writers.writer.Writer.can_accept">can_accept</a></code></li>
<li><code><a title="logger.writers.writer.Writer.input_format" href="writer.html#logger.writers.writer.Writer.input_format">input_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.timeout_writer.TimeoutWriter" href="#logger.writers.timeout_writer.TimeoutWriter">TimeoutWriter</a></code></h4>
<ul class="">
<li><code><a title="logger.writers.timeout_writer.TimeoutWriter.quit" href="#logger.writers.timeout_writer.TimeoutWriter.quit">quit</a></code></li>
<li><code><a title="logger.writers.timeout_writer.TimeoutWriter.write" href="#logger.writers.timeout_writer.TimeoutWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>