<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>logger.writers.udp_writer API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.udp_writer</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.udp_writer.UDPWriter"><code class="flex name class">
<span>class <span class="ident">UDPWriter</span></span>
<span>(</span><span>destination=None,<br>port=None,<br>mc_interface=None,<br>mc_ttl=3,<br>num_retry=2,<br>warning_limit=5,<br>eol='',<br>reuseaddr=False,<br>reuseport=False,<br>quiet=False,<br>encoding='utf-8',<br>encoding_errors='ignore')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UDPWriter(Writer):
    &#34;&#34;&#34;Write UDP packets to network.&#34;&#34;&#34;

    def __init__(self, destination=None, port=None,
                 mc_interface=None, mc_ttl=3, num_retry=2, warning_limit=5, eol=&#39;&#39;,
                 reuseaddr=False, reuseport=False, quiet=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;Write records to a UDP network socket.
        ```
        destination  The destination to send UDP packets to. If &#39;&#39; or None,
                     the UDPWriter will broadcast to 255.255.255.255.  On a
                     system connected to more than one subnet, you&#39;ll want to
                     specify the broadcast address of the network you&#39;re trying
                     to send to (e.g., 192.168.1.255).

        port         Port to which packets should be sent.  REQUIRED

        mc_interface REQUIRED for multicast, the interface to send from.  Can be
                     specified as either IP or a resolvable hostname.

        mc_ttl       For multicast, how many network hops to allow.

        num_retry    Number of times to retry if write fails. If writer exceeds
                     this number, it will give up on writing the message and
                     move on.

        warning_limit  Number of times the writer gives up on writing a message
                     (without any intervening successes) before it gives up complaining
                     about failures.

        eol          If specified, an end of line string to append to record
                     before sending.

        reuseaddr    Specifies wether to set SO_REUSEADDR on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        reuseport    Specifies wether to set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any
                decoding and return raw bytes. Other possible encodings are
                listed in online documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are
                &#39;strict&#39;, &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings
        ```

        &#34;&#34;&#34;
        super().__init__(quiet=quiet, encoding=encoding,
                         encoding_errors=encoding_errors)

        self.num_retry = num_retry
        self.warning_limit = warning_limit
        self.num_warnings = 0
        self.good_writes = 0  # consecutive good writes, for detecting UDP errors

        # &#39;eol&#39; comes in as a (probably escaped) string. We need to
        # unescape it, which means converting to bytes and back.
        if eol is not None and self.encoding:
            eol = self._unescape_str(eol)
        self.eol = eol

        self.target_str = &#39;destination: %s, port: %d&#39; % (destination, port)

        # do name resolution once in the constructor
        #
        # NOTE: This means the hostname must be valid when we start, otherwise
        #       the config_check code will puke.  That&#39;s fine.  The alternative
        #       is we let name resolution happen while we&#39;re running, but then
        #       each failed lookup is going to block our write() routine for a
        #       few seconds - not good.
        #
        # NOTE: This also catches specifying impropperly formatted IP
        #       addresses.  The only way through gethostbyname() w/out throwing
        #       an exception is to provide a valid hostname or IP address.
        #       Propperly formatted IPs just get returned.
        #
        if destination:
            destination = socket.gethostbyname(destination)
        else:
            # If no destination, it&#39;s a broadcast; set dest to special string
            destination = &#39;&lt;broadcast&gt;&#39;

        self.destination = destination

        # make sure user passed in `port`
        #
        # NOTE: We want the order of the arguments to consistently be (ip,
        #       port, ...) across all the network readers/writers... but we
        #       want `destination` to be optional.  All kwargs need to come
        #       after all regular args, so we&#39;ve assigned a default value of
        #       None to `port`.  But don&#39;t be confused, it is REQUIRED.
        #
        if not port:
            raise TypeError(&#39;must specify `port`&#39;)
        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        # multicast options
        if mc_interface:
            # resolve once in constructor
            mc_interface = socket.gethostbyname(mc_interface)
        self.mc_interface = mc_interface
        self.mc_ttl = mc_ttl

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        # socket gets initialized on-demand in write()
        self.socket = None

    ############################
    def __del__(self):
        if self.socket:
            self.socket.close()

    ############################
    def _open_socket(self):
        &#34;&#34;&#34;Do socket prep so we&#39;re ready to write().  Returns socket object or None on
        failure.
        &#34;&#34;&#34;
        udp_socket = socket.socket(family=socket.AF_INET,
                                   type=socket.SOCK_DGRAM,
                                   proto=socket.IPPROTO_UDP)
        if self.reuseaddr:
            udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

        # set multicast/broadcast options
        if self.mc_interface:
            # set the time-to-live for messages
            udp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL,
                                  struct.pack(&#39;b&#39;, self.mc_ttl))
            # set outgoing multicast interface
            udp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF,
                                  socket.inet_aton(self.mc_interface))
        else:
            # maybe broadcast, but very non-trivial to detect broadcast IP, so
            # we set the broadcast flag anytime we&#39;re not doing multicast
            udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)

        try:
            udp_socket.connect((self.destination, self.port))
            return udp_socket
        except OSError as e:
            logging.error(&#39;Unable to connect to %s:%d - %s&#39;, self.destination, self.port, e)
            return None

    ############################
    def write(self, record: Union[str, bytes, DASRecord]):
        &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;

        # See if it&#39;s something we can process, and if not, try digesting
        if not self.can_process_record(record):  # inherited from BaseModule()
            self.digest_record(record)  # inherited from BaseModule()
            return

        if isinstance(record, DASRecord):
            record = record.as_json()

        # Append eol if configured
        if self.eol:
            record += self.eol

        # Encode the record, so we&#39;re dealing with bytes from here on out
        record = self._encode_str(record)

        # Fragment record if needed, and recurse.
        if len(record) &gt; MAXSIZE:
            record_list = []
            max_fragment_size = MAXSIZE - len(FRAGMENT_MARKER)
            fragment_sizes = []
            while len(record) &gt; max_fragment_size:
                r = record[:max_fragment_size]+FRAGMENT_MARKER
                record_list.append(r)
                fragment_sizes.append(str(len(r)))
                record = record[max_fragment_size:]
            # last record doesn&#39;t get FRAGMENT_MARKER
            record_list.append(record)
            fragment_sizes.append(&#34;{} bytes&#34;.format(len(record)))
            fragment_sizes = &#39;, &#39;.join(fragment_sizes)
            logging.info(&#34;write: fragmented record into %d datagrams: %s&#34;,
                         len(record_list), fragment_sizes)
            logging.debug(str(record_list))

            # change our encoding to binary temporarily, because we&#39;ve already
            # encoded to binary and added our marker (which has non-utf chars
            # in it)
            old_encoding = self.encoding
            self.encoding = None
            self.write(record_list)
            # restore old encoding
            self.encoding = old_encoding
            return

        # If socket isn&#39;t connected, try reconnecting. If we can&#39;t
        # reconnect, complain and return without writing.
        if not self.socket:
            self.socket = self._open_socket()
        if not self.socket:
            logging.error(&#39;Unable to write record to %s:%d&#39;,
                          self.destination, self.port)
            return

        num_tries = bytes_sent = 0
        rec_len = len(record)
        while num_tries &lt;= self.num_retry and bytes_sent &lt; rec_len:
            try:
                bytes_sent = self.socket.send(record)

                # If here, write succeeded. Reset warnings
                #
                # NOTE: If the host is unreachable, every other send will fail.
                #       Since UDP doesn&#39;t actually know it failed, the initial
                #       send() cannot fail.  However, the network stack will
                #       see the ICMP host unreachable message and will store
                #       THAT as the the error message for next write, then the
                #       next send fails and clears the error...  Then the next
                #       &#34;succeeds&#34; and the next fails, etc, etc
                #
                #       So we look for 2 consecutive &#34;successful&#34; writes before
                #       resetting num_warnings.
                #
                self.good_writes += 1
                if self.good_writes &gt;= 2:
                    if self.num_warnings == self.warning_limit:
                        logging.info(&#39;UDPWriter.write() succeeded in writing after series of &#39;
                                     &#39;failures; resetting warnings.&#39;)
                    self.num_warnings = 0  # we&#39;ve succeeded

            except (OSError, ConnectionRefusedError) as e:
                # If we failed, complain, unless we&#39;ve already complained too much
                self.good_writes = 0
                if self.num_warnings &lt; self.warning_limit:
                    logging.error(f&#39;UDPWriter: send() error: {self.target_str}: {str(e)}&#39;)
                    if &#39;Message too long&#39; in str(e):
                        logging.error(f&#39;Message length is {rec_len}&#39;)
                    self.num_warnings += 1
                    if self.num_warnings == self.warning_limit:
                        logging.error(&#39;UDPWriter.write() - muting errors&#39;)
            num_tries += 1

        logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                      bytes_sent, rec_len, num_tries)</code></pre>
</details>
<div class="desc"><p>Write UDP packets to network.</p>
<p>Write records to a UDP network socket.</p>
<pre><code>destination  The destination to send UDP packets to. If '' or None,
             the UDPWriter will broadcast to 255.255.255.255.  On a
             system connected to more than one subnet, you'll want to
             specify the broadcast address of the network you're trying
             to send to (e.g., 192.168.1.255).

port         Port to which packets should be sent.  REQUIRED

mc_interface REQUIRED for multicast, the interface to send from.  Can be
             specified as either IP or a resolvable hostname.

mc_ttl       For multicast, how many network hops to allow.

num_retry    Number of times to retry if write fails. If writer exceeds
             this number, it will give up on writing the message and
             move on.

warning_limit  Number of times the writer gives up on writing a message
             (without any intervening successes) before it gives up complaining
             about failures.

eol          If specified, an end of line string to append to record
             before sending.

reuseaddr    Specifies wether to set SO_REUSEADDR on the created socket.  If
             you don't know you need this, don't enable it.

reuseport    Specifies wether to set SO_REUSEPORT on the created socket.  If
             you don't know you need this, don't enable it.

encoding - 'utf-8' by default. If empty or None, do not attempt any
        decoding and return raw bytes. Other possible encodings are
        listed in online documentation here:
        https://docs.python.org/3/library/codecs.html#standard-encodings

encoding_errors - 'ignore' by default. Other error strategies are
        'strict', 'replace', and 'backslashreplace', described here:
        https://docs.python.org/3/howto/unicode.html#encodings
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
<li><a title="logger.utils.base_module.BaseModule" href="../utils/base_module.html#logger.utils.base_module.BaseModule">BaseModule</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.writers.udp_writer.UDPWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self,<br>record: str | bytes | <a title="logger.utils.das_record.DASRecord" href="../utils/das_record.html#logger.utils.das_record.DASRecord">DASRecord</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, record: Union[str, bytes, DASRecord]):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;

    # See if it&#39;s something we can process, and if not, try digesting
    if not self.can_process_record(record):  # inherited from BaseModule()
        self.digest_record(record)  # inherited from BaseModule()
        return

    if isinstance(record, DASRecord):
        record = record.as_json()

    # Append eol if configured
    if self.eol:
        record += self.eol

    # Encode the record, so we&#39;re dealing with bytes from here on out
    record = self._encode_str(record)

    # Fragment record if needed, and recurse.
    if len(record) &gt; MAXSIZE:
        record_list = []
        max_fragment_size = MAXSIZE - len(FRAGMENT_MARKER)
        fragment_sizes = []
        while len(record) &gt; max_fragment_size:
            r = record[:max_fragment_size]+FRAGMENT_MARKER
            record_list.append(r)
            fragment_sizes.append(str(len(r)))
            record = record[max_fragment_size:]
        # last record doesn&#39;t get FRAGMENT_MARKER
        record_list.append(record)
        fragment_sizes.append(&#34;{} bytes&#34;.format(len(record)))
        fragment_sizes = &#39;, &#39;.join(fragment_sizes)
        logging.info(&#34;write: fragmented record into %d datagrams: %s&#34;,
                     len(record_list), fragment_sizes)
        logging.debug(str(record_list))

        # change our encoding to binary temporarily, because we&#39;ve already
        # encoded to binary and added our marker (which has non-utf chars
        # in it)
        old_encoding = self.encoding
        self.encoding = None
        self.write(record_list)
        # restore old encoding
        self.encoding = old_encoding
        return

    # If socket isn&#39;t connected, try reconnecting. If we can&#39;t
    # reconnect, complain and return without writing.
    if not self.socket:
        self.socket = self._open_socket()
    if not self.socket:
        logging.error(&#39;Unable to write record to %s:%d&#39;,
                      self.destination, self.port)
        return

    num_tries = bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt;= self.num_retry and bytes_sent &lt; rec_len:
        try:
            bytes_sent = self.socket.send(record)

            # If here, write succeeded. Reset warnings
            #
            # NOTE: If the host is unreachable, every other send will fail.
            #       Since UDP doesn&#39;t actually know it failed, the initial
            #       send() cannot fail.  However, the network stack will
            #       see the ICMP host unreachable message and will store
            #       THAT as the the error message for next write, then the
            #       next send fails and clears the error...  Then the next
            #       &#34;succeeds&#34; and the next fails, etc, etc
            #
            #       So we look for 2 consecutive &#34;successful&#34; writes before
            #       resetting num_warnings.
            #
            self.good_writes += 1
            if self.good_writes &gt;= 2:
                if self.num_warnings == self.warning_limit:
                    logging.info(&#39;UDPWriter.write() succeeded in writing after series of &#39;
                                 &#39;failures; resetting warnings.&#39;)
                self.num_warnings = 0  # we&#39;ve succeeded

        except (OSError, ConnectionRefusedError) as e:
            # If we failed, complain, unless we&#39;ve already complained too much
            self.good_writes = 0
            if self.num_warnings &lt; self.warning_limit:
                logging.error(f&#39;UDPWriter: send() error: {self.target_str}: {str(e)}&#39;)
                if &#39;Message too long&#39; in str(e):
                    logging.error(f&#39;Message length is {rec_len}&#39;)
                self.num_warnings += 1
                if self.num_warnings == self.warning_limit:
                    logging.error(&#39;UDPWriter.write() - muting errors&#39;)
        num_tries += 1

    logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                  bytes_sent, rec_len, num_tries)</code></pre>
</details>
<div class="desc"><p>Write the record to the network.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.writer.Writer.can_process_record" href="../utils/base_module.html#logger.utils.base_module.BaseModule.can_process_record">can_process_record</a></code></li>
<li><code><a title="logger.writers.writer.Writer.digest_record" href="../utils/base_module.html#logger.utils.base_module.BaseModule.digest_record">digest_record</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.udp_writer.UDPWriter" href="#logger.writers.udp_writer.UDPWriter">UDPWriter</a></code></h4>
<ul class="">
<li><code><a title="logger.writers.udp_writer.UDPWriter.write" href="#logger.writers.udp_writer.UDPWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
