<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>logger.writers.udp_writer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.udp_writer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import json
import ipaddress
import logging
import socket
import struct
import sys

from os.path import dirname, realpath; sys.path.append(dirname(dirname(dirname(realpath(__file__)))))

from logger.utils.formats import Text
from logger.utils.das_record import DASRecord
from logger.writers.network_writer import NetworkWriter

################################################################################
class UDPWriter(NetworkWriter):
  &#34;&#34;&#34;Write UDP packets to network.&#34;&#34;&#34;
  def __init__(self, port, destination=&#39;&#39;,
               interface=&#39;&#39;, # DEPRECATED!
               ttl=3, num_retry=2, eol=&#39;&#39;):
    &#34;&#34;&#34;
    Write text records to a network socket.
    ```
    port         Port to which packets should be sent

    destination  The destination to send UDP packets to. If omitted (or None)
                 is equivalent to specifying destination=&#39;&lt;broadcast&gt;&#39;,
                 which will send to all available interfaces.

                 Setting destination=&#39;255.255.255.255&#39; means broadcast
                 to local network. To broadcast to a specific interface,
                 set destination to the broadcast address for that network.

    interface    DEPRECATED - If specified, the network interface to
                 send from. Preferred usage is to use the &#39;destination&#39;
                 argument and specify the broadcast address of the desired
                 network.

    ttl          For multicast, how many network hops to allow

    num_retry    Number of times to retry if write fails.

    eol          If specified, an end of line string to append to record
                 before sending.
    ```
    &#34;&#34;&#34;
    self.ttl = ttl
    self.num_retry = num_retry
    self.eol = eol

    self.target_str = &#39;interface: %s, destination: %s, port: %d&#39; % (interface, destination, port)

    if interface:
      logging.warning(&#39;DEPRECATED: UDPWriter(interface=%s). Instead of the &#39;
                      &#39;&#34;interface&#34; parameter, UDPWriters should use the&#39;
                      &#39;&#34;destination&#34; parameter. To broadcast over a specific &#39;
                      &#39;interface, specify UDPWriter(destination=&lt;interface &#39;
                      &#39;broadcast address&gt;) address as the destination.&#39;,
                      interface)

    if interface and destination:
      ipaddress.ip_address(interface) # throw a ValueError if bad addr
      ipaddress.ip_address(destination)
      # At the moment, we don&#39;t know how to do both interface and
      # multicast/unicast. If they&#39;ve specified both, then complain
      # and ignore the interface part.
      logging.warning(&#39;UDPWriter doesn\&#39;t yet support specifying both &#39;
                      &#39;interface and destination. Ignoring interface &#39;
                      &#39;specification.&#39;)

    # THE FOLLOWING USE OF interface PARAMETER IS PARTIALLY BROKEN: it
    # will fail if the netmask is not 255.255.255.0. This is why we
    # deprecate the interface param.
    #
    # If they&#39;ve specified the interface we&#39;re supposed to be sending
    # via, then we have to do a little legerdemain: we&#39;re going to
    # connect to the broadcast address of the specified interface as
    # our destination. The broadcast address is just the normal
    # address with the last tuple replaced by &#34;.255&#34;.
    elif interface:
      if interface == &#39;0.0.0.0&#39;:  # local network
        destination = &#39;255.255.255.255&#39;
      elif interface in [&#39;&lt;broadcast&gt;&#39;, &#39;None&#39;]:
        destination = &#39;&lt;broadcast&gt;&#39;
      else:
        # Change interface&#39;s lowest tuple to &#39;broadcast&#39; value (255)
        ipaddress.ip_address(interface)
        destination = interface[:interface.rfind(&#39;.&#39;)] + &#39;.255&#39;

    # If we&#39;ve been given a destination, make sure it&#39;s a valid IP
    elif destination:
      ipaddress.ip_address(destination)

    # If no destination, it&#39;s a broadcast; set flag allowing broadcast and
    # set dest to special string
    else:
      destination = &#39;&lt;broadcast&gt;&#39;

    self.destination = destination
    self.port = port

    # Try opening the socket
    self.socket = self._open_socket()

  ############################
  def _open_socket(self):
    &#34;&#34;&#34;Try to open and return the network socket.
    &#34;&#34;&#34;
    udp_socket = socket.socket(family=socket.AF_INET,
                               type=socket.SOCK_DGRAM,
                               proto=socket.IPPROTO_UDP)
    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
      udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
    except AttributeError:
      logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

    # Set the time-to-live for messages, in case of multicast
    udp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL,
                          struct.pack(&#39;b&#39;, self.ttl))
    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)

    try:
      udp_socket.connect((self.destination, self.port))
      return udp_socket
    except OSError as e:
      logging.warning(&#39;Unable to connect to %s:%d&#39;, self.destination, self.port)
      return None

  ############################
  def write(self, record):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
    # If we don&#39;t have a record, there&#39;s nothing to do
    if not record: return

    # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
    # calling write() on each of the list elements in order.
    if type(record) is list:
      for single_record in record:
        self.write(single_record)
      return

    # If record is not a string, try converting to JSON. If we don&#39;t know
    # how, throw a hail Mary and force it into str format
    if not type(record) is str:
      if type(record) in [int, float, bool, list, dict]:
        record = json.dumps(record)
      elif type(record) is DASRecord:
        record = record.as_json()
      else:
        record = str(record)
    if self.eol:
      record += self.eol

    # If socket isn&#39;t connected, try reconnecting. If we can&#39;t
    # reconnect, complain and return without writing.
    if not self.socket:
      self.socket = self._open_socket()
    if not self.socket:
      logging.error(&#39;Unable to write record to %s:%d&#39;,
                      self.destination, self.port)
      return

    num_tries = bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt; self.num_retry and bytes_sent &lt; rec_len:
      try:
        bytes_sent = self.socket.send(record.encode(&#39;utf-8&#39;))
      except ConnectionRefusedError as e:
        logging.error(&#39;ERROR: %s: %s&#39;, self.target_str, str(e))
      num_tries += 1

    logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                    bytes_sent, rec_len, num_tries)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.udp_writer.UDPWriter"><code class="flex name class">
<span>class <span class="ident">UDPWriter</span></span>
<span>(</span><span>port, destination='', interface='', ttl=3, num_retry=2, eol='')</span>
</code></dt>
<dd>
<div class="desc"><p>Write UDP packets to network.</p>
<p>Write text records to a network socket.</p>
<pre><code>port         Port to which packets should be sent

destination  The destination to send UDP packets to. If omitted (or None)
             is equivalent to specifying destination='&lt;broadcast&gt;',
             which will send to all available interfaces.

             Setting destination='255.255.255.255' means broadcast
             to local network. To broadcast to a specific interface,
             set destination to the broadcast address for that network.

interface    DEPRECATED - If specified, the network interface to
             send from. Preferred usage is to use the 'destination'
             argument and specify the broadcast address of the desired
             network.

ttl          For multicast, how many network hops to allow

num_retry    Number of times to retry if write fails.

eol          If specified, an end of line string to append to record
             before sending.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UDPWriter(NetworkWriter):
  &#34;&#34;&#34;Write UDP packets to network.&#34;&#34;&#34;
  def __init__(self, port, destination=&#39;&#39;,
               interface=&#39;&#39;, # DEPRECATED!
               ttl=3, num_retry=2, eol=&#39;&#39;):
    &#34;&#34;&#34;
    Write text records to a network socket.
    ```
    port         Port to which packets should be sent

    destination  The destination to send UDP packets to. If omitted (or None)
                 is equivalent to specifying destination=&#39;&lt;broadcast&gt;&#39;,
                 which will send to all available interfaces.

                 Setting destination=&#39;255.255.255.255&#39; means broadcast
                 to local network. To broadcast to a specific interface,
                 set destination to the broadcast address for that network.

    interface    DEPRECATED - If specified, the network interface to
                 send from. Preferred usage is to use the &#39;destination&#39;
                 argument and specify the broadcast address of the desired
                 network.

    ttl          For multicast, how many network hops to allow

    num_retry    Number of times to retry if write fails.

    eol          If specified, an end of line string to append to record
                 before sending.
    ```
    &#34;&#34;&#34;
    self.ttl = ttl
    self.num_retry = num_retry
    self.eol = eol

    self.target_str = &#39;interface: %s, destination: %s, port: %d&#39; % (interface, destination, port)

    if interface:
      logging.warning(&#39;DEPRECATED: UDPWriter(interface=%s). Instead of the &#39;
                      &#39;&#34;interface&#34; parameter, UDPWriters should use the&#39;
                      &#39;&#34;destination&#34; parameter. To broadcast over a specific &#39;
                      &#39;interface, specify UDPWriter(destination=&lt;interface &#39;
                      &#39;broadcast address&gt;) address as the destination.&#39;,
                      interface)

    if interface and destination:
      ipaddress.ip_address(interface) # throw a ValueError if bad addr
      ipaddress.ip_address(destination)
      # At the moment, we don&#39;t know how to do both interface and
      # multicast/unicast. If they&#39;ve specified both, then complain
      # and ignore the interface part.
      logging.warning(&#39;UDPWriter doesn\&#39;t yet support specifying both &#39;
                      &#39;interface and destination. Ignoring interface &#39;
                      &#39;specification.&#39;)

    # THE FOLLOWING USE OF interface PARAMETER IS PARTIALLY BROKEN: it
    # will fail if the netmask is not 255.255.255.0. This is why we
    # deprecate the interface param.
    #
    # If they&#39;ve specified the interface we&#39;re supposed to be sending
    # via, then we have to do a little legerdemain: we&#39;re going to
    # connect to the broadcast address of the specified interface as
    # our destination. The broadcast address is just the normal
    # address with the last tuple replaced by &#34;.255&#34;.
    elif interface:
      if interface == &#39;0.0.0.0&#39;:  # local network
        destination = &#39;255.255.255.255&#39;
      elif interface in [&#39;&lt;broadcast&gt;&#39;, &#39;None&#39;]:
        destination = &#39;&lt;broadcast&gt;&#39;
      else:
        # Change interface&#39;s lowest tuple to &#39;broadcast&#39; value (255)
        ipaddress.ip_address(interface)
        destination = interface[:interface.rfind(&#39;.&#39;)] + &#39;.255&#39;

    # If we&#39;ve been given a destination, make sure it&#39;s a valid IP
    elif destination:
      ipaddress.ip_address(destination)

    # If no destination, it&#39;s a broadcast; set flag allowing broadcast and
    # set dest to special string
    else:
      destination = &#39;&lt;broadcast&gt;&#39;

    self.destination = destination
    self.port = port

    # Try opening the socket
    self.socket = self._open_socket()

  ############################
  def _open_socket(self):
    &#34;&#34;&#34;Try to open and return the network socket.
    &#34;&#34;&#34;
    udp_socket = socket.socket(family=socket.AF_INET,
                               type=socket.SOCK_DGRAM,
                               proto=socket.IPPROTO_UDP)
    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
    try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
      udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
    except AttributeError:
      logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

    # Set the time-to-live for messages, in case of multicast
    udp_socket.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL,
                          struct.pack(&#39;b&#39;, self.ttl))
    udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)

    try:
      udp_socket.connect((self.destination, self.port))
      return udp_socket
    except OSError as e:
      logging.warning(&#39;Unable to connect to %s:%d&#39;, self.destination, self.port)
      return None

  ############################
  def write(self, record):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
    # If we don&#39;t have a record, there&#39;s nothing to do
    if not record: return

    # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
    # calling write() on each of the list elements in order.
    if type(record) is list:
      for single_record in record:
        self.write(single_record)
      return

    # If record is not a string, try converting to JSON. If we don&#39;t know
    # how, throw a hail Mary and force it into str format
    if not type(record) is str:
      if type(record) in [int, float, bool, list, dict]:
        record = json.dumps(record)
      elif type(record) is DASRecord:
        record = record.as_json()
      else:
        record = str(record)
    if self.eol:
      record += self.eol

    # If socket isn&#39;t connected, try reconnecting. If we can&#39;t
    # reconnect, complain and return without writing.
    if not self.socket:
      self.socket = self._open_socket()
    if not self.socket:
      logging.error(&#39;Unable to write record to %s:%d&#39;,
                      self.destination, self.port)
      return

    num_tries = bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt; self.num_retry and bytes_sent &lt; rec_len:
      try:
        bytes_sent = self.socket.send(record.encode(&#39;utf-8&#39;))
      except ConnectionRefusedError as e:
        logging.error(&#39;ERROR: %s: %s&#39;, self.target_str, str(e))
      num_tries += 1

    logging.debug(&#39;UDPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                    bytes_sent, rec_len, num_tries)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.network_writer.NetworkWriter" href="network_writer.html#logger.writers.network_writer.NetworkWriter">NetworkWriter</a></li>
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.network_writer.NetworkWriter" href="network_writer.html#logger.writers.network_writer.NetworkWriter">NetworkWriter</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.network_writer.NetworkWriter.can_accept" href="writer.html#logger.writers.writer.Writer.can_accept">can_accept</a></code></li>
<li><code><a title="logger.writers.network_writer.NetworkWriter.input_format" href="writer.html#logger.writers.writer.Writer.input_format">input_format</a></code></li>
<li><code><a title="logger.writers.network_writer.NetworkWriter.write" href="network_writer.html#logger.writers.network_writer.NetworkWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.udp_writer.UDPWriter" href="#logger.writers.udp_writer.UDPWriter">UDPWriter</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>