<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.writers.tcp_writer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.tcp_writer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import json
import logging
import socket
import sys

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.writers.writer import Writer  # noqa: E402


class TCPWriter(Writer):
    &#34;&#34;&#34;Write TCP packtes to network.&#34;&#34;&#34;
    def __init__(self, destination, port,
                 num_retry=2, warning_limit=5, eol=&#39;&#39;,
                 reuseaddr=False, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        Write records to a TCP network socket.

        ```
        destination  The destination to send TCP packets to.  Can be resolvable hostname
                     or valid IP address.

        port         Port to which packets should be sent

        num_retry    Number of times to retry if write fails.

        warning_limit  Number of times the writer gives up on writing a message
                     (without any intervening successes) before it gives up complaining
                     about failures.

        eol          If specified, an end of line string to append to record
                     before sending

        reuseaddr    Specifies wether to set SO_REUSEADDR on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        reuseport    Specifies wether to set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any
                decoding and return raw bytes. Other possible encodings are
                listed in online documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are
                &#39;strict&#39;, &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings

        ```
        &#34;&#34;&#34;

        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        self.num_retry = num_retry
        self.warning_limit = warning_limit
        self.num_warnings = 0

        # &#39;eol&#39; comes in as a (probably escaped) string. We need to
        # unescape it, which means converting to bytes and back.
        if eol is not None and self.encoding:
            eol = self._unescape_str(eol)
        self.eol = eol

        # do name resolution once in the constructor
        #
        # NOTE: This means the hostname must be valid when we start, otherwise
        #       the config_check code will puke.  That&#39;s fine.  The alternative
        #       is we let name resolution happen while we&#39;re running, but then
        #       each failed lookup is going to block our write() routine for a
        #       few seconds - not good.
        #
        # NOTE: This also catches specifying impropperly formatted IP
        #       addresses.  The only way through gethostbyname() w/out throwing
        #       an exception is to provide a valid hostname or IP address.
        #       Propperly formatted IPs just get returned.
        #
        self.destination = socket.gethostbyname(destination)

        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        # socket gets initialized on-demand in write()
        #
        # NOTE: Since connect() can actually fail w/ a TCP socket, we don&#39;t try
        #       that here.  Let&#39;s just do safe things.
        #
        self.socket = None

    ############################
    def __del__(self):
        if self.socket:
            logging.debug(&#39;__del__: closing socket&#39;)
            self._close_socket(self.socket)

    ############################
    def _open_socket(self):
        &#34;&#34;&#34;Do socket prep so we&#39;re ready to write().  Returns socket object or None on
        failure.
        &#34;&#34;&#34;
        this_socket = socket.socket(family=socket.AF_INET,
                                    type=socket.SOCK_STREAM,
                                    proto=socket.IPPROTO_TCP)
        if self.reuseaddr:
            this_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                this_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

        # Try connecting
        try:
            this_socket.connect((self.destination, self.port))
        except OSError as e:
            if self.num_warnings &lt; self.warning_limit:
                logging.error(&#39;Unable to connect to %s:%d: %s&#39;, self.destination, self.port, e)
                self.num_warnings += 1
                if self.num_warnings == self.warning_limit:
                    logging.error(&#39;TCPWriter._open_socket() - muting errors&#39;)
            return None

        # success, reset warning counter
        if self.num_warnings == self.warning_limit:
            logging.info(&#39;TCPWriter._open_socket() successfully connected after a series of &#39;
                         &#39;failures; restting warnings.&#39;)
        self.num_warnings = 0
        return this_socket

    ############################
    def _close_socket(self, s):
        s.shutdown(socket.SHUT_RDWR)
        s.close()

    ############################
    def write(self, record):
        &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
        # If we don&#39;t have a record, there&#39;s nothing to do
        if not record:
            return

        # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
        # calling write() on each of the list elements in order.
        if isinstance(record, list):
            for single_record in record:
                self.write(single_record)
            return

        # Append eol if configured
        if self.eol:
            record += self.eol

        # NOTE: Unlike UDP socket, which really only can detect failure during
        #       send() (and even then only very poorly), a TCP connect() can
        #       fail, so we need to track attempts to connect in order to honor
        #       `num_retry` on a disconnected socket.
        #
        #       We also need to tear down and start over with a fresh connect()
        #       if send() fails.
        #
        num_tries = 0
        bytes_sent = 0
        rec_len = len(record)
        while num_tries &lt;= self.num_retry and bytes_sent &lt; rec_len:
            num_tries += 1
            # attempt to connect socket if needed, up to `num_tries` times
            if not self.socket:
                self.socket = self._open_socket()
            if not self.socket:
                # no need for further error messages, _open_socket() will have
                # already complained sufficiently
                continue

            # attempt to verify we&#39;re really connected
            #
            # NOTE: This is because the only way to detect a closed TCP socket
            #       is via recv(), which is awkward when we&#39;re trying to
            #       guarantee a write was successful.
            #
            #         https://stackoverflow.com/questions/49457631/c-server-socket-closed-but-client-socket-still-able-send-two-more-packages
            #
            #         &#34;send() just puts the data in the kernel socket buffer,
            #         it doesn&#39;t wait for the data to be transmitted or the
            #         server to acknowledge receipt of it.
            #
            #         You don&#39;t get SIGPIPE until the data is transmitted and
            #         the server rejects it by sending a RST segment.
            #
            #         It works this way because each direction of a TCP
            #         connection is treated independently. When the server
            #         closes the socket, it sends a FIN segment. This just
            #         tells the client that the server is done sending data, it
            #         doesn&#39;t mean that the server cannot receive data. There&#39;s
            #         nothing in the TCP protocol that allows the server to
            #         inform the client of this. So the only way to find out
            #         that it&#39;s not accepting any more data is when the client
            #         gets that RST response.
            #
            #         Informing the client that they shouldn&#39;t send anything
            #         more is usually done in the application protocol, since
            #         it&#39;s not available in TCP.&#34;
            #
            #       So it might take a couple &#34;successful&#34; send() calls before
            #       the socket layer notices nobody&#39;s home on the other end.
            #
            #       Fine then, let&#39;s do a 1 byte recv() w/ flags arranged so we
            #       don&#39;t really read off the socket forcing it to raise
            #       BlockingIOError if the socket is still connected.  Not
            #       perfect, because the remote side could still close after
            #       this call but before our send() below, but it&#39;s something.
            #
            try:
                # If the socket is still connected, this will raise
                # BlockingIOError.  If it&#39;s not, it returns 0 bytes.
                msg = self.socket.recv(1, socket.MSG_DONTWAIT | socket.MSG_PEEK)
                logging.error(&#39;TCPWriter: connection closed&#39;)
                self.num_warnings += 1
                self._close_socket(self.socket)
                self.socket = None
                continue
            except BlockingIOError as e:
                pass

            # we&#39;re connected, try sending
            try:
                bytes_sent = self.socket.send(self._encode_str(record))
            except OSError as e:
                # send failed, we need to disconnect and start over
                #
                # NOTE: In order to get this far, we have to have successfully
                #       connected, which means we JUST reset self.num_warnings
                #
                logging.error(&#39;TCPWriter: send() error: %s:%d: %s&#39;, self.destination, self.port, str(e))
                self.num_warnings += 1
                self._close_socket(self.socket)
                self.socket = None
                continue

            # check to see if we really wrote it all
            if bytes_sent &lt; rec_len:
                logging.warning(&#39;TCPWriter: send() did not send the whole record: &#39;
                                &#39;bytes_sent=%d, rec_len=%d&#39;, bytes_sent, rec_len)

        logging.debug(&#39;TCPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                      bytes_sent, rec_len, num_tries)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.tcp_writer.TCPWriter"><code class="flex name class">
<span>class <span class="ident">TCPWriter</span></span>
<span>(</span><span>destination, port, num_retry=2, warning_limit=5, eol='', reuseaddr=False, reuseport=False, encoding='utf-8', encoding_errors='ignore')</span>
</code></dt>
<dd>
<div class="desc"><p>Write TCP packtes to network.</p>
<p>Write records to a TCP network socket.</p>
<pre><code>destination  The destination to send TCP packets to.  Can be resolvable hostname
             or valid IP address.

port         Port to which packets should be sent

num_retry    Number of times to retry if write fails.

warning_limit  Number of times the writer gives up on writing a message
             (without any intervening successes) before it gives up complaining
             about failures.

eol          If specified, an end of line string to append to record
             before sending

reuseaddr    Specifies wether to set SO_REUSEADDR on the created socket.  If
             you don't know you need this, don't enable it.

reuseport    Specifies wether to set SO_REUSEPORT on the created socket.  If
             you don't know you need this, don't enable it.

encoding - 'utf-8' by default. If empty or None, do not attempt any
        decoding and return raw bytes. Other possible encodings are
        listed in online documentation here:
        https://docs.python.org/3/library/codecs.html#standard-encodings

encoding_errors - 'ignore' by default. Other error strategies are
        'strict', 'replace', and 'backslashreplace', described here:
        https://docs.python.org/3/howto/unicode.html#encodings

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TCPWriter(Writer):
    &#34;&#34;&#34;Write TCP packtes to network.&#34;&#34;&#34;
    def __init__(self, destination, port,
                 num_retry=2, warning_limit=5, eol=&#39;&#39;,
                 reuseaddr=False, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        Write records to a TCP network socket.

        ```
        destination  The destination to send TCP packets to.  Can be resolvable hostname
                     or valid IP address.

        port         Port to which packets should be sent

        num_retry    Number of times to retry if write fails.

        warning_limit  Number of times the writer gives up on writing a message
                     (without any intervening successes) before it gives up complaining
                     about failures.

        eol          If specified, an end of line string to append to record
                     before sending

        reuseaddr    Specifies wether to set SO_REUSEADDR on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        reuseport    Specifies wether to set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any
                decoding and return raw bytes. Other possible encodings are
                listed in online documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are
                &#39;strict&#39;, &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings

        ```
        &#34;&#34;&#34;

        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        self.num_retry = num_retry
        self.warning_limit = warning_limit
        self.num_warnings = 0

        # &#39;eol&#39; comes in as a (probably escaped) string. We need to
        # unescape it, which means converting to bytes and back.
        if eol is not None and self.encoding:
            eol = self._unescape_str(eol)
        self.eol = eol

        # do name resolution once in the constructor
        #
        # NOTE: This means the hostname must be valid when we start, otherwise
        #       the config_check code will puke.  That&#39;s fine.  The alternative
        #       is we let name resolution happen while we&#39;re running, but then
        #       each failed lookup is going to block our write() routine for a
        #       few seconds - not good.
        #
        # NOTE: This also catches specifying impropperly formatted IP
        #       addresses.  The only way through gethostbyname() w/out throwing
        #       an exception is to provide a valid hostname or IP address.
        #       Propperly formatted IPs just get returned.
        #
        self.destination = socket.gethostbyname(destination)

        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        # socket gets initialized on-demand in write()
        #
        # NOTE: Since connect() can actually fail w/ a TCP socket, we don&#39;t try
        #       that here.  Let&#39;s just do safe things.
        #
        self.socket = None

    ############################
    def __del__(self):
        if self.socket:
            logging.debug(&#39;__del__: closing socket&#39;)
            self._close_socket(self.socket)

    ############################
    def _open_socket(self):
        &#34;&#34;&#34;Do socket prep so we&#39;re ready to write().  Returns socket object or None on
        failure.
        &#34;&#34;&#34;
        this_socket = socket.socket(family=socket.AF_INET,
                                    type=socket.SOCK_STREAM,
                                    proto=socket.IPPROTO_TCP)
        if self.reuseaddr:
            this_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                this_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported&#39;)

        # Try connecting
        try:
            this_socket.connect((self.destination, self.port))
        except OSError as e:
            if self.num_warnings &lt; self.warning_limit:
                logging.error(&#39;Unable to connect to %s:%d: %s&#39;, self.destination, self.port, e)
                self.num_warnings += 1
                if self.num_warnings == self.warning_limit:
                    logging.error(&#39;TCPWriter._open_socket() - muting errors&#39;)
            return None

        # success, reset warning counter
        if self.num_warnings == self.warning_limit:
            logging.info(&#39;TCPWriter._open_socket() successfully connected after a series of &#39;
                         &#39;failures; restting warnings.&#39;)
        self.num_warnings = 0
        return this_socket

    ############################
    def _close_socket(self, s):
        s.shutdown(socket.SHUT_RDWR)
        s.close()

    ############################
    def write(self, record):
        &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
        # If we don&#39;t have a record, there&#39;s nothing to do
        if not record:
            return

        # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
        # calling write() on each of the list elements in order.
        if isinstance(record, list):
            for single_record in record:
                self.write(single_record)
            return

        # Append eol if configured
        if self.eol:
            record += self.eol

        # NOTE: Unlike UDP socket, which really only can detect failure during
        #       send() (and even then only very poorly), a TCP connect() can
        #       fail, so we need to track attempts to connect in order to honor
        #       `num_retry` on a disconnected socket.
        #
        #       We also need to tear down and start over with a fresh connect()
        #       if send() fails.
        #
        num_tries = 0
        bytes_sent = 0
        rec_len = len(record)
        while num_tries &lt;= self.num_retry and bytes_sent &lt; rec_len:
            num_tries += 1
            # attempt to connect socket if needed, up to `num_tries` times
            if not self.socket:
                self.socket = self._open_socket()
            if not self.socket:
                # no need for further error messages, _open_socket() will have
                # already complained sufficiently
                continue

            # attempt to verify we&#39;re really connected
            #
            # NOTE: This is because the only way to detect a closed TCP socket
            #       is via recv(), which is awkward when we&#39;re trying to
            #       guarantee a write was successful.
            #
            #         https://stackoverflow.com/questions/49457631/c-server-socket-closed-but-client-socket-still-able-send-two-more-packages
            #
            #         &#34;send() just puts the data in the kernel socket buffer,
            #         it doesn&#39;t wait for the data to be transmitted or the
            #         server to acknowledge receipt of it.
            #
            #         You don&#39;t get SIGPIPE until the data is transmitted and
            #         the server rejects it by sending a RST segment.
            #
            #         It works this way because each direction of a TCP
            #         connection is treated independently. When the server
            #         closes the socket, it sends a FIN segment. This just
            #         tells the client that the server is done sending data, it
            #         doesn&#39;t mean that the server cannot receive data. There&#39;s
            #         nothing in the TCP protocol that allows the server to
            #         inform the client of this. So the only way to find out
            #         that it&#39;s not accepting any more data is when the client
            #         gets that RST response.
            #
            #         Informing the client that they shouldn&#39;t send anything
            #         more is usually done in the application protocol, since
            #         it&#39;s not available in TCP.&#34;
            #
            #       So it might take a couple &#34;successful&#34; send() calls before
            #       the socket layer notices nobody&#39;s home on the other end.
            #
            #       Fine then, let&#39;s do a 1 byte recv() w/ flags arranged so we
            #       don&#39;t really read off the socket forcing it to raise
            #       BlockingIOError if the socket is still connected.  Not
            #       perfect, because the remote side could still close after
            #       this call but before our send() below, but it&#39;s something.
            #
            try:
                # If the socket is still connected, this will raise
                # BlockingIOError.  If it&#39;s not, it returns 0 bytes.
                msg = self.socket.recv(1, socket.MSG_DONTWAIT | socket.MSG_PEEK)
                logging.error(&#39;TCPWriter: connection closed&#39;)
                self.num_warnings += 1
                self._close_socket(self.socket)
                self.socket = None
                continue
            except BlockingIOError as e:
                pass

            # we&#39;re connected, try sending
            try:
                bytes_sent = self.socket.send(self._encode_str(record))
            except OSError as e:
                # send failed, we need to disconnect and start over
                #
                # NOTE: In order to get this far, we have to have successfully
                #       connected, which means we JUST reset self.num_warnings
                #
                logging.error(&#39;TCPWriter: send() error: %s:%d: %s&#39;, self.destination, self.port, str(e))
                self.num_warnings += 1
                self._close_socket(self.socket)
                self.socket = None
                continue

            # check to see if we really wrote it all
            if bytes_sent &lt; rec_len:
                logging.warning(&#39;TCPWriter: send() did not send the whole record: &#39;
                                &#39;bytes_sent=%d, rec_len=%d&#39;, bytes_sent, rec_len)

        logging.debug(&#39;TCPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                      bytes_sent, rec_len, num_tries)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.writers.tcp_writer.TCPWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the record to the network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, record):
    &#34;&#34;&#34;Write the record to the network.&#34;&#34;&#34;
    # If we don&#39;t have a record, there&#39;s nothing to do
    if not record:
        return

    # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
    # calling write() on each of the list elements in order.
    if isinstance(record, list):
        for single_record in record:
            self.write(single_record)
        return

    # Append eol if configured
    if self.eol:
        record += self.eol

    # NOTE: Unlike UDP socket, which really only can detect failure during
    #       send() (and even then only very poorly), a TCP connect() can
    #       fail, so we need to track attempts to connect in order to honor
    #       `num_retry` on a disconnected socket.
    #
    #       We also need to tear down and start over with a fresh connect()
    #       if send() fails.
    #
    num_tries = 0
    bytes_sent = 0
    rec_len = len(record)
    while num_tries &lt;= self.num_retry and bytes_sent &lt; rec_len:
        num_tries += 1
        # attempt to connect socket if needed, up to `num_tries` times
        if not self.socket:
            self.socket = self._open_socket()
        if not self.socket:
            # no need for further error messages, _open_socket() will have
            # already complained sufficiently
            continue

        # attempt to verify we&#39;re really connected
        #
        # NOTE: This is because the only way to detect a closed TCP socket
        #       is via recv(), which is awkward when we&#39;re trying to
        #       guarantee a write was successful.
        #
        #         https://stackoverflow.com/questions/49457631/c-server-socket-closed-but-client-socket-still-able-send-two-more-packages
        #
        #         &#34;send() just puts the data in the kernel socket buffer,
        #         it doesn&#39;t wait for the data to be transmitted or the
        #         server to acknowledge receipt of it.
        #
        #         You don&#39;t get SIGPIPE until the data is transmitted and
        #         the server rejects it by sending a RST segment.
        #
        #         It works this way because each direction of a TCP
        #         connection is treated independently. When the server
        #         closes the socket, it sends a FIN segment. This just
        #         tells the client that the server is done sending data, it
        #         doesn&#39;t mean that the server cannot receive data. There&#39;s
        #         nothing in the TCP protocol that allows the server to
        #         inform the client of this. So the only way to find out
        #         that it&#39;s not accepting any more data is when the client
        #         gets that RST response.
        #
        #         Informing the client that they shouldn&#39;t send anything
        #         more is usually done in the application protocol, since
        #         it&#39;s not available in TCP.&#34;
        #
        #       So it might take a couple &#34;successful&#34; send() calls before
        #       the socket layer notices nobody&#39;s home on the other end.
        #
        #       Fine then, let&#39;s do a 1 byte recv() w/ flags arranged so we
        #       don&#39;t really read off the socket forcing it to raise
        #       BlockingIOError if the socket is still connected.  Not
        #       perfect, because the remote side could still close after
        #       this call but before our send() below, but it&#39;s something.
        #
        try:
            # If the socket is still connected, this will raise
            # BlockingIOError.  If it&#39;s not, it returns 0 bytes.
            msg = self.socket.recv(1, socket.MSG_DONTWAIT | socket.MSG_PEEK)
            logging.error(&#39;TCPWriter: connection closed&#39;)
            self.num_warnings += 1
            self._close_socket(self.socket)
            self.socket = None
            continue
        except BlockingIOError as e:
            pass

        # we&#39;re connected, try sending
        try:
            bytes_sent = self.socket.send(self._encode_str(record))
        except OSError as e:
            # send failed, we need to disconnect and start over
            #
            # NOTE: In order to get this far, we have to have successfully
            #       connected, which means we JUST reset self.num_warnings
            #
            logging.error(&#39;TCPWriter: send() error: %s:%d: %s&#39;, self.destination, self.port, str(e))
            self.num_warnings += 1
            self._close_socket(self.socket)
            self.socket = None
            continue

        # check to see if we really wrote it all
        if bytes_sent &lt; rec_len:
            logging.warning(&#39;TCPWriter: send() did not send the whole record: &#39;
                            &#39;bytes_sent=%d, rec_len=%d&#39;, bytes_sent, rec_len)

    logging.debug(&#39;TCPWriter.write() wrote %d/%d bytes after %d tries&#39;,
                  bytes_sent, rec_len, num_tries)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.writer.Writer.can_accept" href="writer.html#logger.writers.writer.Writer.can_accept">can_accept</a></code></li>
<li><code><a title="logger.writers.writer.Writer.input_format" href="writer.html#logger.writers.writer.Writer.input_format">input_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.tcp_writer.TCPWriter" href="#logger.writers.tcp_writer.TCPWriter">TCPWriter</a></code></h4>
<ul class="">
<li><code><a title="logger.writers.tcp_writer.TCPWriter.write" href="#logger.writers.tcp_writer.TCPWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>