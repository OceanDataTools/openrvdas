<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.writers.regex_logfile_writer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.writers.regex_logfile_writer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import re
import sys

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.utils import timestamp  # noqa: E402
from logger.writers.writer import Writer  # noqa: E402
from logger.writers.file_writer import FileWriter  # noqa: E402


class RegexLogfileWriter(Writer):
    &#34;&#34;&#34;Write to the specified filebase, with datestamp appended. If filebase
    is a &lt;regex&gt;:&lt;filebase&gt; dict, write records to every filebase whose
    regex appears in the record.
    &#34;&#34;&#34;
    def __init__(self, filebase=None, flush=True,
                 time_format=timestamp.TIME_FORMAT,
                 date_format=timestamp.DATE_FORMAT,
                 split_char=&#39; &#39;, suffix=&#39;&#39;, header=None,
                 header_file=None, rollover_hourly=False,
                 quiet=False):
        &#34;&#34;&#34;Write timestamped text records to a filebase. The filebase will
        have the current date appended, in keeping with R2R format
        recommendations (http://www.rvdata.us/operators/directory). When the
        timestamped date on records rolls over to next day, create a new file
        with the new date suffix.

        If filebase is a dict of &lt;string&gt;:&lt;filebase&gt; pairs, The writer will
        attempt to match a &lt;string&gt; in the dict to each record it receives.
        It will write the record to the filebase corresponding to the first
        string it matches (Note that the order of comparison is not
        guaranteed!). If no strings match, the record will be written to the
        standalone filebase provided.
        ```
        filebase        A filebase string to write to or a dict mapping
                        &lt;string&gt;:&lt;filebase&gt;.

        flush           If True (default), flush after every write() call

        date_fomat      A strftime-compatible string, such as &#39;%Y-%m-%d&#39;;
                        defaults to whatever&#39;s defined in
                        utils.timestamps.DATE_FORMAT.

        split_char      Delimiter between timestamp and rest of message

        suffix          string to apply to the end of the log filename

        header          Add the specified header string to each file.

        header_file     Add the content of the specified file to each file.

        rollover_hourly Set files to truncate by hour.  By default files will
                        truncate by day

        quiet           If True, don&#39;t complain if a record doesn&#39;t match
                        any mapped prefix
        ```
        &#34;&#34;&#34;
        self.filebase = filebase
        self.flush = flush
        self.time_format = time_format
        self.date_format = date_format
        self.split_char = split_char
        self.suffix = suffix
        self.header = header
        self.header_file = header_file
        self.rollover_hourly = rollover_hourly
        self.quiet = quiet

        # If our filebase is a dict, we&#39;re going to be doing our
        # fancy pattern-&gt;filebase mapping.
        self.do_filebase_mapping = isinstance(self.filebase, dict)

        if self.do_filebase_mapping:
            # Do our matches faster by precompiling
            self.compiled_filebase_map = {
                pattern: re.compile(pattern) for pattern in self.filebase
            }
        self.current_filename = {}
        self.writer = {}

    ############################
    def write(self, record):
        &#34;&#34;&#34;Note: Assume record begins with a timestamp string.&#34;&#34;&#34;
        # If record is None, or an empty string
        if not record:
            return

        # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
        # calling write() on each of the list elements in order.
        if isinstance(record, list):
            for single_record in record:
                self.write(single_record)
            return

        if not isinstance(record, str):
            if not self.quiet:
                logging.error(f&#39;LogfileWriter.write() - record not &#39;
                              f&#39;timestamped: {record}&#39;)
            return

        # Get the timestamp we&#39;ll be using
        try:  # Try to extract timestamp from record
            time_str = record.split(self.split_char)[0]
            ts = timestamp.timestamp(time_str, time_format=self.time_format)
        except ValueError:
            if not self.quiet:
                logging.error(&#39;LogfileWriter.write() - bad timestamp: &#34;%s&#34;&#39;, record)
                return

        # Now parse ts into hour and date strings
        hr_str = self.rollover_hourly and \
            timestamp.date_str(ts, date_format=&#39;_%H00&#39;) or &#34;&#34;
        date_str = timestamp.date_str(ts, date_format=self.date_format)
        time_str = date_str + hr_str + self.suffix
        logging.debug(&#39;LogfileWriter time_str: %s&#39;, time_str)

        # Figure out where we&#39;re going to write
        if self.do_filebase_mapping:
            matched_patterns = [self.write_if_match(record, pattern, time_str)
                                for pattern in self.filebase]
            if True not in matched_patterns:
                if not self.quiet:
                    logging.warning(f&#39;No patterns matched in PatternLogfileWriter &#39;
                                    f&#39;for record &#34;{record}&#34;&#39;)
        else:
            pattern = &#39;fixed&#39;  # just an arbitrary fixed pattern
            filename = self.filebase + &#39;-&#39; + time_str
            self.write_filename(record, pattern, filename)

    ############################
    def write_filename(self, record, pattern, filename):
        &#34;&#34;&#34;Write record to filename. If it&#39;s the first time we&#39;re writing to
        this filename, create the appropriate FileWriter and insert it into
        the map for the relevant pattern.&#34;&#34;&#34;

        # Are we currently writing to this file? If not, open/create it.
        if not filename == self.current_filename.get(pattern, None):
            logging.info(&#39;LogfileWriter opening new file: %s&#39;, filename)
            self.current_filename[pattern] = filename
            self.writer[pattern] = FileWriter(filename=filename,
                                              header=self.header,
                                              header_file=self.header_file,
                                              flush=self.flush)
        # Now, if our logic is correct, should *always* have a matching_writer
        matching_writer = self.writer.get(pattern)
        matching_writer.write(record)

    ############################
    def write_if_match(self, record, pattern, time_str):
        &#34;&#34;&#34;If the record matches the pattern, write to the matching filebase.&#34;&#34;&#34;
        # Find the compiled regex matching the pattern
        regex = self.compiled_filebase_map.get(pattern, None)
        if not regex:
            logging.error(f&#39;System error: found no regex pattern matching &#34;{pattern}&#34;!&#39;)
            return None

        # If the pattern isn&#39;t in this record, go home quietly
        if regex.search(record) is None:
            return None

        # Otherwise, we write.
        filebase = self.filebase.get(pattern, None)
        if filebase is None:
            logging.error(f&#39;System error: found no filebase matching pattern &#34;{pattern}&#34;!&#39;)
            return None

        filename = filebase + &#39;-&#39; + time_str
        self.write_filename(record, pattern, filename)
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.writers.regex_logfile_writer.RegexLogfileWriter"><code class="flex name class">
<span>class <span class="ident">RegexLogfileWriter</span></span>
<span>(</span><span>filebase=None, flush=True, time_format='%Y-%m-%dT%H:%M:%S.%fZ', date_format='%Y-%m-%d', split_char=' ', suffix='', header=None, header_file=None, rollover_hourly=False, quiet=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write to the specified filebase, with datestamp appended. If filebase
is a <regex>:<filebase> dict, write records to every filebase whose
regex appears in the record.</p>
<p>Write timestamped text records to a filebase. The filebase will
have the current date appended, in keeping with R2R format
recommendations (<a href="http://www.rvdata.us/operators/directory">http://www.rvdata.us/operators/directory</a>). When the
timestamped date on records rolls over to next day, create a new file
with the new date suffix.</p>
<p>If filebase is a dict of <string>:<filebase> pairs, The writer will
attempt to match a <string> in the dict to each record it receives.
It will write the record to the filebase corresponding to the first
string it matches (Note that the order of comparison is not
guaranteed!). If no strings match, the record will be written to the
standalone filebase provided.</p>
<pre><code>filebase        A filebase string to write to or a dict mapping
                &lt;string&gt;:&lt;filebase&gt;.

flush           If True (default), flush after every write() call

date_fomat      A strftime-compatible string, such as '%Y-%m-%d';
                defaults to whatever's defined in
                utils.timestamps.DATE_FORMAT.

split_char      Delimiter between timestamp and rest of message

suffix          string to apply to the end of the log filename

header          Add the specified header string to each file.

header_file     Add the content of the specified file to each file.

rollover_hourly Set files to truncate by hour.  By default files will
                truncate by day

quiet           If True, don't complain if a record doesn't match
                any mapped prefix
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexLogfileWriter(Writer):
    &#34;&#34;&#34;Write to the specified filebase, with datestamp appended. If filebase
    is a &lt;regex&gt;:&lt;filebase&gt; dict, write records to every filebase whose
    regex appears in the record.
    &#34;&#34;&#34;
    def __init__(self, filebase=None, flush=True,
                 time_format=timestamp.TIME_FORMAT,
                 date_format=timestamp.DATE_FORMAT,
                 split_char=&#39; &#39;, suffix=&#39;&#39;, header=None,
                 header_file=None, rollover_hourly=False,
                 quiet=False):
        &#34;&#34;&#34;Write timestamped text records to a filebase. The filebase will
        have the current date appended, in keeping with R2R format
        recommendations (http://www.rvdata.us/operators/directory). When the
        timestamped date on records rolls over to next day, create a new file
        with the new date suffix.

        If filebase is a dict of &lt;string&gt;:&lt;filebase&gt; pairs, The writer will
        attempt to match a &lt;string&gt; in the dict to each record it receives.
        It will write the record to the filebase corresponding to the first
        string it matches (Note that the order of comparison is not
        guaranteed!). If no strings match, the record will be written to the
        standalone filebase provided.
        ```
        filebase        A filebase string to write to or a dict mapping
                        &lt;string&gt;:&lt;filebase&gt;.

        flush           If True (default), flush after every write() call

        date_fomat      A strftime-compatible string, such as &#39;%Y-%m-%d&#39;;
                        defaults to whatever&#39;s defined in
                        utils.timestamps.DATE_FORMAT.

        split_char      Delimiter between timestamp and rest of message

        suffix          string to apply to the end of the log filename

        header          Add the specified header string to each file.

        header_file     Add the content of the specified file to each file.

        rollover_hourly Set files to truncate by hour.  By default files will
                        truncate by day

        quiet           If True, don&#39;t complain if a record doesn&#39;t match
                        any mapped prefix
        ```
        &#34;&#34;&#34;
        self.filebase = filebase
        self.flush = flush
        self.time_format = time_format
        self.date_format = date_format
        self.split_char = split_char
        self.suffix = suffix
        self.header = header
        self.header_file = header_file
        self.rollover_hourly = rollover_hourly
        self.quiet = quiet

        # If our filebase is a dict, we&#39;re going to be doing our
        # fancy pattern-&gt;filebase mapping.
        self.do_filebase_mapping = isinstance(self.filebase, dict)

        if self.do_filebase_mapping:
            # Do our matches faster by precompiling
            self.compiled_filebase_map = {
                pattern: re.compile(pattern) for pattern in self.filebase
            }
        self.current_filename = {}
        self.writer = {}

    ############################
    def write(self, record):
        &#34;&#34;&#34;Note: Assume record begins with a timestamp string.&#34;&#34;&#34;
        # If record is None, or an empty string
        if not record:
            return

        # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
        # calling write() on each of the list elements in order.
        if isinstance(record, list):
            for single_record in record:
                self.write(single_record)
            return

        if not isinstance(record, str):
            if not self.quiet:
                logging.error(f&#39;LogfileWriter.write() - record not &#39;
                              f&#39;timestamped: {record}&#39;)
            return

        # Get the timestamp we&#39;ll be using
        try:  # Try to extract timestamp from record
            time_str = record.split(self.split_char)[0]
            ts = timestamp.timestamp(time_str, time_format=self.time_format)
        except ValueError:
            if not self.quiet:
                logging.error(&#39;LogfileWriter.write() - bad timestamp: &#34;%s&#34;&#39;, record)
                return

        # Now parse ts into hour and date strings
        hr_str = self.rollover_hourly and \
            timestamp.date_str(ts, date_format=&#39;_%H00&#39;) or &#34;&#34;
        date_str = timestamp.date_str(ts, date_format=self.date_format)
        time_str = date_str + hr_str + self.suffix
        logging.debug(&#39;LogfileWriter time_str: %s&#39;, time_str)

        # Figure out where we&#39;re going to write
        if self.do_filebase_mapping:
            matched_patterns = [self.write_if_match(record, pattern, time_str)
                                for pattern in self.filebase]
            if True not in matched_patterns:
                if not self.quiet:
                    logging.warning(f&#39;No patterns matched in PatternLogfileWriter &#39;
                                    f&#39;for record &#34;{record}&#34;&#39;)
        else:
            pattern = &#39;fixed&#39;  # just an arbitrary fixed pattern
            filename = self.filebase + &#39;-&#39; + time_str
            self.write_filename(record, pattern, filename)

    ############################
    def write_filename(self, record, pattern, filename):
        &#34;&#34;&#34;Write record to filename. If it&#39;s the first time we&#39;re writing to
        this filename, create the appropriate FileWriter and insert it into
        the map for the relevant pattern.&#34;&#34;&#34;

        # Are we currently writing to this file? If not, open/create it.
        if not filename == self.current_filename.get(pattern, None):
            logging.info(&#39;LogfileWriter opening new file: %s&#39;, filename)
            self.current_filename[pattern] = filename
            self.writer[pattern] = FileWriter(filename=filename,
                                              header=self.header,
                                              header_file=self.header_file,
                                              flush=self.flush)
        # Now, if our logic is correct, should *always* have a matching_writer
        matching_writer = self.writer.get(pattern)
        matching_writer.write(record)

    ############################
    def write_if_match(self, record, pattern, time_str):
        &#34;&#34;&#34;If the record matches the pattern, write to the matching filebase.&#34;&#34;&#34;
        # Find the compiled regex matching the pattern
        regex = self.compiled_filebase_map.get(pattern, None)
        if not regex:
            logging.error(f&#39;System error: found no regex pattern matching &#34;{pattern}&#34;!&#39;)
            return None

        # If the pattern isn&#39;t in this record, go home quietly
        if regex.search(record) is None:
            return None

        # Otherwise, we write.
        filebase = self.filebase.get(pattern, None)
        if filebase is None:
            logging.error(f&#39;System error: found no filebase matching pattern &#34;{pattern}&#34;!&#39;)
            return None

        filename = filebase + &#39;-&#39; + time_str
        self.write_filename(record, pattern, filename)
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.writers.regex_logfile_writer.RegexLogfileWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Note: Assume record begins with a timestamp string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, record):
    &#34;&#34;&#34;Note: Assume record begins with a timestamp string.&#34;&#34;&#34;
    # If record is None, or an empty string
    if not record:
        return

    # If we&#39;ve got a list, hope it&#39;s a list of records. Recurse,
    # calling write() on each of the list elements in order.
    if isinstance(record, list):
        for single_record in record:
            self.write(single_record)
        return

    if not isinstance(record, str):
        if not self.quiet:
            logging.error(f&#39;LogfileWriter.write() - record not &#39;
                          f&#39;timestamped: {record}&#39;)
        return

    # Get the timestamp we&#39;ll be using
    try:  # Try to extract timestamp from record
        time_str = record.split(self.split_char)[0]
        ts = timestamp.timestamp(time_str, time_format=self.time_format)
    except ValueError:
        if not self.quiet:
            logging.error(&#39;LogfileWriter.write() - bad timestamp: &#34;%s&#34;&#39;, record)
            return

    # Now parse ts into hour and date strings
    hr_str = self.rollover_hourly and \
        timestamp.date_str(ts, date_format=&#39;_%H00&#39;) or &#34;&#34;
    date_str = timestamp.date_str(ts, date_format=self.date_format)
    time_str = date_str + hr_str + self.suffix
    logging.debug(&#39;LogfileWriter time_str: %s&#39;, time_str)

    # Figure out where we&#39;re going to write
    if self.do_filebase_mapping:
        matched_patterns = [self.write_if_match(record, pattern, time_str)
                            for pattern in self.filebase]
        if True not in matched_patterns:
            if not self.quiet:
                logging.warning(f&#39;No patterns matched in PatternLogfileWriter &#39;
                                f&#39;for record &#34;{record}&#34;&#39;)
    else:
        pattern = &#39;fixed&#39;  # just an arbitrary fixed pattern
        filename = self.filebase + &#39;-&#39; + time_str
        self.write_filename(record, pattern, filename)</code></pre>
</details>
</dd>
<dt id="logger.writers.regex_logfile_writer.RegexLogfileWriter.write_filename"><code class="name flex">
<span>def <span class="ident">write_filename</span></span>(<span>self, record, pattern, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Write record to filename. If it's the first time we're writing to
this filename, create the appropriate FileWriter and insert it into
the map for the relevant pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_filename(self, record, pattern, filename):
    &#34;&#34;&#34;Write record to filename. If it&#39;s the first time we&#39;re writing to
    this filename, create the appropriate FileWriter and insert it into
    the map for the relevant pattern.&#34;&#34;&#34;

    # Are we currently writing to this file? If not, open/create it.
    if not filename == self.current_filename.get(pattern, None):
        logging.info(&#39;LogfileWriter opening new file: %s&#39;, filename)
        self.current_filename[pattern] = filename
        self.writer[pattern] = FileWriter(filename=filename,
                                          header=self.header,
                                          header_file=self.header_file,
                                          flush=self.flush)
    # Now, if our logic is correct, should *always* have a matching_writer
    matching_writer = self.writer.get(pattern)
    matching_writer.write(record)</code></pre>
</details>
</dd>
<dt id="logger.writers.regex_logfile_writer.RegexLogfileWriter.write_if_match"><code class="name flex">
<span>def <span class="ident">write_if_match</span></span>(<span>self, record, pattern, time_str)</span>
</code></dt>
<dd>
<div class="desc"><p>If the record matches the pattern, write to the matching filebase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_if_match(self, record, pattern, time_str):
    &#34;&#34;&#34;If the record matches the pattern, write to the matching filebase.&#34;&#34;&#34;
    # Find the compiled regex matching the pattern
    regex = self.compiled_filebase_map.get(pattern, None)
    if not regex:
        logging.error(f&#39;System error: found no regex pattern matching &#34;{pattern}&#34;!&#39;)
        return None

    # If the pattern isn&#39;t in this record, go home quietly
    if regex.search(record) is None:
        return None

    # Otherwise, we write.
    filebase = self.filebase.get(pattern, None)
    if filebase is None:
        logging.error(f&#39;System error: found no filebase matching pattern &#34;{pattern}&#34;!&#39;)
        return None

    filename = filebase + &#39;-&#39; + time_str
    self.write_filename(record, pattern, filename)
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.writers.writer.Writer" href="writer.html#logger.writers.writer.Writer">Writer</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.writers.writer.Writer.can_accept" href="writer.html#logger.writers.writer.Writer.can_accept">can_accept</a></code></li>
<li><code><a title="logger.writers.writer.Writer.input_format" href="writer.html#logger.writers.writer.Writer.input_format">input_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.writers" href="index.html">logger.writers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.writers.regex_logfile_writer.RegexLogfileWriter" href="#logger.writers.regex_logfile_writer.RegexLogfileWriter">RegexLogfileWriter</a></code></h4>
<ul class="">
<li><code><a title="logger.writers.regex_logfile_writer.RegexLogfileWriter.write" href="#logger.writers.regex_logfile_writer.RegexLogfileWriter.write">write</a></code></li>
<li><code><a title="logger.writers.regex_logfile_writer.RegexLogfileWriter.write_filename" href="#logger.writers.regex_logfile_writer.RegexLogfileWriter.write_filename">write_filename</a></code></li>
<li><code><a title="logger.writers.regex_logfile_writer.RegexLogfileWriter.write_if_match" href="#logger.writers.regex_logfile_writer.RegexLogfileWriter.write_if_match">write_if_match</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>