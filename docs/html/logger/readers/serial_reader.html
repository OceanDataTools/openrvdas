<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.readers.serial_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.serial_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import sys

# Don&#39;t freak out if pyserial isn&#39;t installed - unless they actually
# try to instantiate a SerialReader
try:
    import serial
    SERIAL_MODULE_FOUND = True
except ModuleNotFoundError:
    SERIAL_MODULE_FOUND = False

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.readers.reader import Reader  # noqa: E402


################################################################################
class SerialReader(Reader):
    &#34;&#34;&#34;
    Read records from a serial port.
    &#34;&#34;&#34;

    def __init__(self,  port, baudrate=9600, bytesize=8, parity=&#39;N&#39;,
                 stopbits=1, timeout=None, xonxoff=False, rtscts=False,
                 write_timeout=None, dsrdtr=False, inter_byte_timeout=None,
                 exclusive=None, max_bytes=None, eol=None,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;If max_bytes is specified on initialization, read up to that many
        bytes when read() is called. If eol is not specified, read() will
        read up to the first newline it receives. In both cases, if
        timeout is specified, it will return after timeout with as many
        bytes as it has succeeded in reading.

        By default, the SerialReader will read until it encounters a newline character.
        This behavior may be overwritten by specifying

        max_bytes - if specified, and write_timeout is None, read this many bytes per record.
                If write_timeout is not None, it may return fewer bytes.

        eol - if specified, read up until encountering the specified eol

        By default, the SerialReader will assume that records are encoded in UTF-8, and will
        ignore non unicode characters it encounters. These defaults may be changed by specifying

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings

        command line example:
        ```
          # Read serial port ttyr05 expecting a LF as end of record
          logger/listener/listen.py  --serial port=/dev/ttyr05,eol=&#39;\r&#39;
        ```
        config example:
        ```
          class: SerialReader
          kwargs:
            baudrate: 4800
            port: /dev/ttyr05
            eol: \r
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if not SERIAL_MODULE_FOUND:
            raise RuntimeError(&#39;Serial port functionality not available. Please &#39;
                               &#39;install Python module pyserial.&#39;)
        try:
            self.serial = serial.Serial(port=port, baudrate=baudrate,
                                        bytesize=bytesize, parity=parity,
                                        stopbits=stopbits, timeout=timeout,
                                        xonxoff=xonxoff, rtscts=rtscts,
                                        write_timeout=write_timeout, dsrdtr=dsrdtr,
                                        inter_byte_timeout=inter_byte_timeout,
                                        exclusive=exclusive)
        except (serial.SerialException, serial.serialutil.SerialException) as e:
            logging.fatal(&#39;Failed to open serial port %s: %s&#39;, port, e)
            raise

        self.max_bytes = max_bytes
        self.encoding = encoding
        self.encoding_errors = encoding_errors

        # &#39;eol&#39; comes in as a (probably escaped) string. We need to
        # unescape it, which means converting to bytes and back.
        #
        # NOTE: This block is different from SerialWriter because we use
        #       readline() in here, which already looks for trailing &#39;\n&#39; and
        #       handles encoding itself.
        #
        if eol is not None and self.encoding:
            eol = self._encode_str(eol, unescape=True)
        self.eol = eol

    ############################
    def read(self):
        try:
            if self.eol:
                record = self.serial.read_until(expected=self.eol, size=self.max_bytes)
                # read_until()&#39;s record includes a trailing &#39;eol&#39;, strip it off
                #
                # NOTE: But don&#39;t use rstrip which just looks explicitly for
                #       whitespace
                #
                record = record.rsplit(self.eol)[0]
            elif self.max_bytes:
                # no stripping on this one, just use exactly what we got
                record = self.serial.read(size=self.max_bytes)
            else:
                # readline()&#39;s record includes the trailing &#39;\n&#39;, strip it off
                record = self.serial.readline().rstrip()

            if not record:
                return None
            return self._decode_bytes(record)

        except KeyboardInterrupt as e:
            raise e
        except serial.serialutil.SerialException as e:
            logging.error(str(e))
            return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.serial_reader.SerialReader"><code class="flex name class">
<span>class <span class="ident">SerialReader</span></span>
<span>(</span><span>port, baudrate=9600, bytesize=8, parity='N', stopbits=1, timeout=None, xonxoff=False, rtscts=False, write_timeout=None, dsrdtr=False, inter_byte_timeout=None, exclusive=None, max_bytes=None, eol=None, encoding='utf-8', encoding_errors='ignore')</span>
</code></dt>
<dd>
<div class="desc"><p>Read records from a serial port.</p>
<p>If max_bytes is specified on initialization, read up to that many
bytes when read() is called. If eol is not specified, read() will
read up to the first newline it receives. In both cases, if
timeout is specified, it will return after timeout with as many
bytes as it has succeeded in reading.</p>
<p>By default, the SerialReader will read until it encounters a newline character.
This behavior may be overwritten by specifying</p>
<p>max_bytes - if specified, and write_timeout is None, read this many bytes per record.
If write_timeout is not None, it may return fewer bytes.</p>
<p>eol - if specified, read up until encountering the specified eol</p>
<p>By default, the SerialReader will assume that records are encoded in UTF-8, and will
ignore non unicode characters it encounters. These defaults may be changed by specifying</p>
<p>encoding - 'utf-8' by default. If empty or None, do not attempt any decoding
and return raw bytes. Other possible encodings are listed in online
documentation here:
<a href="https://docs.python.org/3/library/codecs.html#standard-encodings">https://docs.python.org/3/library/codecs.html#standard-encodings</a></p>
<p>encoding_errors - 'ignore' by default. Other error strategies are 'strict',
'replace', and 'backslashreplace', described here:
<a href="https://docs.python.org/3/howto/unicode.html#encodings">https://docs.python.org/3/howto/unicode.html#encodings</a></p>
<p>command line example:</p>
<pre><code>  # Read serial port ttyr05 expecting a LF as end of record
  logger/listener/listen.py  --serial port=/dev/ttyr05,eol='
'
</code></pre>
<p>config example:</p>
<pre><code>  class: SerialReader
  kwargs:
    baudrate: 4800
    port: /dev/ttyr05
    eol: 
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialReader(Reader):
    &#34;&#34;&#34;
    Read records from a serial port.
    &#34;&#34;&#34;

    def __init__(self,  port, baudrate=9600, bytesize=8, parity=&#39;N&#39;,
                 stopbits=1, timeout=None, xonxoff=False, rtscts=False,
                 write_timeout=None, dsrdtr=False, inter_byte_timeout=None,
                 exclusive=None, max_bytes=None, eol=None,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;If max_bytes is specified on initialization, read up to that many
        bytes when read() is called. If eol is not specified, read() will
        read up to the first newline it receives. In both cases, if
        timeout is specified, it will return after timeout with as many
        bytes as it has succeeded in reading.

        By default, the SerialReader will read until it encounters a newline character.
        This behavior may be overwritten by specifying

        max_bytes - if specified, and write_timeout is None, read this many bytes per record.
                If write_timeout is not None, it may return fewer bytes.

        eol - if specified, read up until encountering the specified eol

        By default, the SerialReader will assume that records are encoded in UTF-8, and will
        ignore non unicode characters it encounters. These defaults may be changed by specifying

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings

        command line example:
        ```
          # Read serial port ttyr05 expecting a LF as end of record
          logger/listener/listen.py  --serial port=/dev/ttyr05,eol=&#39;\r&#39;
        ```
        config example:
        ```
          class: SerialReader
          kwargs:
            baudrate: 4800
            port: /dev/ttyr05
            eol: \r
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if not SERIAL_MODULE_FOUND:
            raise RuntimeError(&#39;Serial port functionality not available. Please &#39;
                               &#39;install Python module pyserial.&#39;)
        try:
            self.serial = serial.Serial(port=port, baudrate=baudrate,
                                        bytesize=bytesize, parity=parity,
                                        stopbits=stopbits, timeout=timeout,
                                        xonxoff=xonxoff, rtscts=rtscts,
                                        write_timeout=write_timeout, dsrdtr=dsrdtr,
                                        inter_byte_timeout=inter_byte_timeout,
                                        exclusive=exclusive)
        except (serial.SerialException, serial.serialutil.SerialException) as e:
            logging.fatal(&#39;Failed to open serial port %s: %s&#39;, port, e)
            raise

        self.max_bytes = max_bytes
        self.encoding = encoding
        self.encoding_errors = encoding_errors

        # &#39;eol&#39; comes in as a (probably escaped) string. We need to
        # unescape it, which means converting to bytes and back.
        #
        # NOTE: This block is different from SerialWriter because we use
        #       readline() in here, which already looks for trailing &#39;\n&#39; and
        #       handles encoding itself.
        #
        if eol is not None and self.encoding:
            eol = self._encode_str(eol, unescape=True)
        self.eol = eol

    ############################
    def read(self):
        try:
            if self.eol:
                record = self.serial.read_until(expected=self.eol, size=self.max_bytes)
                # read_until()&#39;s record includes a trailing &#39;eol&#39;, strip it off
                #
                # NOTE: But don&#39;t use rstrip which just looks explicitly for
                #       whitespace
                #
                record = record.rsplit(self.eol)[0]
            elif self.max_bytes:
                # no stripping on this one, just use exactly what we got
                record = self.serial.read(size=self.max_bytes)
            else:
                # readline()&#39;s record includes the trailing &#39;\n&#39;, strip it off
                record = self.serial.readline().rstrip()

            if not record:
                return None
            return self._decode_bytes(record)

        except KeyboardInterrupt as e:
            raise e
        except serial.serialutil.SerialException as e:
            logging.error(str(e))
            return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="logger.readers.polled_serial_reader.PolledSerialReader" href="polled_serial_reader.html#logger.readers.polled_serial_reader.PolledSerialReader">PolledSerialReader</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.reader.Reader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
<li><code><a title="logger.readers.reader.Reader.read" href="reader.html#logger.readers.reader.Reader.read">read</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.serial_reader.SerialReader" href="#logger.readers.serial_reader.SerialReader">SerialReader</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>