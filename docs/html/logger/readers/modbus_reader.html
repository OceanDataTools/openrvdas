<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.readers.modbus_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.modbus_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import socket
import struct
import sys
from time import sleep

# Don&#39;t freak out if pyModbusTCP isn&#39;t installed - unless they actually
# try to instantiate a ModBusReader
try:
    from pyModbusTCP.client import ModbusClient
    MODBUS_MODULE_FOUND = True
except ModuleNotFoundError:
    MODBUS_MODULE_FOUND = False

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.readers.reader import Reader  # noqa: E402
from logger.utils.formats import Text  # noqa: E402


################################################################################
class ModBusTCPReader(Reader):
    &#34;&#34;&#34;
    Read registers from a ModBusTCP device.
    &#34;&#34;&#34;
    ############################

    def __init__(self, registers, host=&#39;localhost&#39;, port=502,
                 interval=10,  sep=&#39; &#39;, encoding=&#39;utf-8&#39;,
                 encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        ```
        registers  A comma-separated list of integers and/or ranges. A range
                   is an int:int pair, where either or both of the ints may
                   be omitted to mean the extreme values (0 or sys.maxsize).
        ```
        Example:
        ```
          reader = ModBusReader(&#39;3,5:7,9,11&#39;)

          record = reader.read()
        ```
        should yield ``&#39;&lt;reg_3&gt; &lt;reg_5&gt; &lt;reg_6&gt; &lt;reg_7&gt; &lt;reg_9&gt; &lt;reg_11&gt;&#39;``.

        ```
        host       Host to listen to for packets

        port       Port to listen to for packets

        interval   Interval in seconds to poll for new data

        sep        How to seperate the register values in the output record

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings
        ```
        &#34;&#34;&#34;

        super().__init__(output_format=Text,
                         encoding=encoding,
                         encoding_errors=encoding_errors)

        if not MODBUS_MODULE_FOUND:
            raise RuntimeError(&#39;Modbus functionality not available. Please &#39;
                               &#39;install Python module pyModbusTCP.&#39;)

        if registers.endswith(&#34;:&#34;):
            raise ValueError(&#39;Registers value cannot end with an ambiguous &#39;
                             &#39;maximum register number (i.e. &#34;5:&#34;).&#39;)

        self.registers = []
        try:
            for register in registers.split(&#39;,&#39;):
                logging.debug(&#39;ModBusReader parsing register &#34;%s&#34;&#39;, register)
                # If register spec is a range, num:num, store as tuple of ints
                if register.find(&#39;:&#39;) &gt; -1:
                    (start, end) = register.split(&#39;:&#39;)
                    if start == &#39;&#39;:  # if missing start, e.g.   &#39;:5&#39;
                        start = 0
                    if end == &#39;&#39;:  # if missing end, e.g.   &#39;1:&#39;
                        raise ValueError(&#39;Register value range cannot end with &#39;
                                         &#39;an ambiguous maximum register number &#39;
                                         &#39;(i.e. &#34;5:&#34;).&#39;)
                    self.registers.concat((int(start), int(end)-int(start)))

                # If register is a simple number
                else:
                    self.registers.append(int(register))

        except ValueError as e:
            logging.error(&#39;Bad register format &#34;%s&#34; - %s&#39;, register, e)
            raise e

        self.sep = sep
        self.interval = interval
        self.client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)

    ############################
    def read(self):
        &#34;&#34;&#34;
        Read the specified registers. Return values as a text record. Wait the
        specified interval before reading again
        &#34;&#34;&#34;

        try:
            readings = []
            for register in self.registers:
                if isinstance(register, tuple):
                    readings.append(self.client.read_holding_registers(register[0],register[1]))
                else:
                    readings.append(self.client.read_holding_registers(register,1))

            record = self.sep.join(regs)
        except OSError as e:
            logging.error(&#39;ModBusReader error: %s&#39;, str(e))
            return None
        logging.debug(&#39;ModBusReader.read() received %d bytes&#39;, len(record))
        return self._decode_bytes(record)

        sleep(self.interval)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.modbus_reader.ModBusTCPReader"><code class="flex name class">
<span>class <span class="ident">ModBusTCPReader</span></span>
<span>(</span><span>registers, host='localhost', port=502, interval=10, sep=' ', encoding='utf-8', encoding_errors='ignore')</span>
</code></dt>
<dd>
<div class="desc"><p>Read registers from a ModBusTCP device.</p>
<pre><code>registers  A comma-separated list of integers and/or ranges. A range
           is an int:int pair, where either or both of the ints may
           be omitted to mean the extreme values (0 or sys.maxsize).
</code></pre>
<p>Example:</p>
<pre><code>  reader = ModBusReader('3,5:7,9,11')

  record = reader.read()
</code></pre>
<p>should yield <code>'&lt;reg_3&gt; &lt;reg_5&gt; &lt;reg_6&gt; &lt;reg_7&gt; &lt;reg_9&gt; &lt;reg_11&gt;'</code>.</p>
<pre><code>host       Host to listen to for packets

port       Port to listen to for packets

interval   Interval in seconds to poll for new data

sep        How to seperate the register values in the output record

encoding - 'utf-8' by default. If empty or None, do not attempt any decoding
        and return raw bytes. Other possible encodings are listed in online
        documentation here:
        https://docs.python.org/3/library/codecs.html#standard-encodings

encoding_errors - 'ignore' by default. Other error strategies are 'strict',
        'replace', and 'backslashreplace', described here:
        https://docs.python.org/3/howto/unicode.html#encodings
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModBusTCPReader(Reader):
    &#34;&#34;&#34;
    Read registers from a ModBusTCP device.
    &#34;&#34;&#34;
    ############################

    def __init__(self, registers, host=&#39;localhost&#39;, port=502,
                 interval=10,  sep=&#39; &#39;, encoding=&#39;utf-8&#39;,
                 encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        ```
        registers  A comma-separated list of integers and/or ranges. A range
                   is an int:int pair, where either or both of the ints may
                   be omitted to mean the extreme values (0 or sys.maxsize).
        ```
        Example:
        ```
          reader = ModBusReader(&#39;3,5:7,9,11&#39;)

          record = reader.read()
        ```
        should yield ``&#39;&lt;reg_3&gt; &lt;reg_5&gt; &lt;reg_6&gt; &lt;reg_7&gt; &lt;reg_9&gt; &lt;reg_11&gt;&#39;``.

        ```
        host       Host to listen to for packets

        port       Port to listen to for packets

        interval   Interval in seconds to poll for new data

        sep        How to seperate the register values in the output record

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings
        ```
        &#34;&#34;&#34;

        super().__init__(output_format=Text,
                         encoding=encoding,
                         encoding_errors=encoding_errors)

        if not MODBUS_MODULE_FOUND:
            raise RuntimeError(&#39;Modbus functionality not available. Please &#39;
                               &#39;install Python module pyModbusTCP.&#39;)

        if registers.endswith(&#34;:&#34;):
            raise ValueError(&#39;Registers value cannot end with an ambiguous &#39;
                             &#39;maximum register number (i.e. &#34;5:&#34;).&#39;)

        self.registers = []
        try:
            for register in registers.split(&#39;,&#39;):
                logging.debug(&#39;ModBusReader parsing register &#34;%s&#34;&#39;, register)
                # If register spec is a range, num:num, store as tuple of ints
                if register.find(&#39;:&#39;) &gt; -1:
                    (start, end) = register.split(&#39;:&#39;)
                    if start == &#39;&#39;:  # if missing start, e.g.   &#39;:5&#39;
                        start = 0
                    if end == &#39;&#39;:  # if missing end, e.g.   &#39;1:&#39;
                        raise ValueError(&#39;Register value range cannot end with &#39;
                                         &#39;an ambiguous maximum register number &#39;
                                         &#39;(i.e. &#34;5:&#34;).&#39;)
                    self.registers.concat((int(start), int(end)-int(start)))

                # If register is a simple number
                else:
                    self.registers.append(int(register))

        except ValueError as e:
            logging.error(&#39;Bad register format &#34;%s&#34; - %s&#39;, register, e)
            raise e

        self.sep = sep
        self.interval = interval
        self.client = ModbusClient(host=host, port=port, auto_open=True, auto_close=True)

    ############################
    def read(self):
        &#34;&#34;&#34;
        Read the specified registers. Return values as a text record. Wait the
        specified interval before reading again
        &#34;&#34;&#34;

        try:
            readings = []
            for register in self.registers:
                if isinstance(register, tuple):
                    readings.append(self.client.read_holding_registers(register[0],register[1]))
                else:
                    readings.append(self.client.read_holding_registers(register,1))

            record = self.sep.join(regs)
        except OSError as e:
            logging.error(&#39;ModBusReader error: %s&#39;, str(e))
            return None
        logging.debug(&#39;ModBusReader.read() received %d bytes&#39;, len(record))
        return self._decode_bytes(record)

        sleep(self.interval)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.readers.modbus_reader.ModBusTCPReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the specified registers. Return values as a text record. Wait the
specified interval before reading again</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    &#34;&#34;&#34;
    Read the specified registers. Return values as a text record. Wait the
    specified interval before reading again
    &#34;&#34;&#34;

    try:
        readings = []
        for register in self.registers:
            if isinstance(register, tuple):
                readings.append(self.client.read_holding_registers(register[0],register[1]))
            else:
                readings.append(self.client.read_holding_registers(register,1))

        record = self.sep.join(regs)
    except OSError as e:
        logging.error(&#39;ModBusReader error: %s&#39;, str(e))
        return None
    logging.debug(&#39;ModBusReader.read() received %d bytes&#39;, len(record))
    return self._decode_bytes(record)

    sleep(self.interval)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.reader.Reader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.modbus_reader.ModBusTCPReader" href="#logger.readers.modbus_reader.ModBusTCPReader">ModBusTCPReader</a></code></h4>
<ul class="">
<li><code><a title="logger.readers.modbus_reader.ModBusTCPReader.read" href="#logger.readers.modbus_reader.ModBusTCPReader.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>