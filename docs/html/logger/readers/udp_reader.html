<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.readers.udp_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.udp_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import socket
import sys

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.readers.reader import Reader  # noqa: E402

# The UDP header&#39;s `length` field sets a theoretical limit of 65,535 bytes
# (8-byte header + 65,527 bytes of data) for a UDP datagram.  Technically, IPV4
# or IPv6 headers use up some of that size, so actual maximum data sent per
# datagram is slightly less.
#
# UDP receivers should always request the max, though, because if you request
# less than what&#39;s on the wire, you get what you asked for and the rest gets
# tossed on the floor.  There&#39;s no built-in error detection/correction in UDP,
# so that would mess things up pretty good.
READ_BUFFER_SIZE = 65535

# On the send side of things, we can (and do) detect when a write has failed
# because the user&#39;s `record` was too big.  This is usually because the user is
# trying to send huge datagrams after looking up the &#34;theoretical max size of a
# datagram&#34; on wikipedia.  Well, it&#39;s called &#34;theoretical&#34; for a reason.  It&#39;s
# really the maximum size of the data portion of a UDP datagram, but that
# doesn&#39;t take into account extra header for IPv4/IPv6 or seemingly random
# system-level caps (e.g., Mac&#39;s socket implementation set maximum udp send
# size to 9K).
#
# When UDPWriter detects this condition, it fragments the record into smaller
# records and appends each fragment with this FRAGMENT_MARKER.  Inside
# UDPReader.read(), we check to see if a received datagram ends with this
# marker, and if it does, we read another datagram and combine the results
# (over and over until we get a datagram that doesn&#39;t end with the marker).
FRAGMENT_MARKER = b&#39;\xff\xffTOOBIG\xff\xff&#39;


################################################################################
class UDPReader(Reader):
    &#34;&#34;&#34;Read UDP packets from network.&#34;&#34;&#34;
    ############################
    def __init__(self, interface=None, port=None, mc_group=None,
                 reuseaddr=False, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;, eol=None,
                 this_is_a_test=False):
        &#34;&#34;&#34;
        ```
        interface    IP (or resolvable name) of interface to listen on.  None or &#39;&#39;
                     will listen on INADDR_ANY (all interfaces).  If joining a
                     multicast group and None or &#39;&#39; specified, this will default
                     to whatever the system&#39;s hostname resolves to.  This IP should
                     not be on the loopback network (OK for testing, but won&#39;t work
                     in the real world).

        port         Port to listen to for packets.  REQUIRED

        mc_group     If specified, IP address of multicast group id to subscribe to.

        reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding     &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                     and return raw bytes. Other possible encodings are listed in
                     online documentation here:
                     https://docs. python.org/3/library/codecs.html#standard-encodings

        encoding_errors &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                        &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                        https://docs.python.org/3/howto/unicode.html#encodings

        eol          split the record by the eol character if present.

        this_is_a_test - If True, recognize that this is being called in a unittest, so
                don&#39;t output warnings about not using loopback addresses.
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if interface:
            # resolve once in constructor
            interface = socket.gethostbyname(interface)
        else:
            interface = &#39;&#39;
        self.interface = interface

        # make sure user passed in `port`
        #
        # NOTE: We want the order of the arguments to consistently be (ip,
        #       port, ...) across all the network readers/writers... but we
        #       want `interface` to be optional.  All kwargs need to come after
        #       all regular args, so we&#39;ve assigned a default value of None to
        #       `port`.  But don&#39;t be confused, it is REQUIRED.
        #
        if not port:
            raise TypeError(&#39;must specify `port`&#39;)
        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        # prep multicast parameters
        if mc_group:
            # resolve once in constructor
            mc_group = socket.gethostbyname(mc_group)
            if not interface:
                # multicast needs to specify interface to use, so let&#39;s pick a
                # sane default
                #
                # NOTE: This means hostname cannot be an alias to localhost, or
                #       you won&#39;t be able to send IGMP packets correctly.
                #
                self.interface = socket.gethostbyname(socket.gethostname())

        self.mc_group = mc_group

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        self.eol = eol

        self.this_is_a_test = this_is_a_test

        # socket gets initialized on-demand in read()
        self.socket = None

    ############################
    def __del__(self):
        if self.socket:
            self.socket.close()

    ############################
    def _open_socket(self):
        &#34;&#34;&#34;Do socket prep so we&#39;re ready to read().  Returns socket object or None on
        failure.
        &#34;&#34;&#34;
        sock = socket.socket(family=socket.AF_INET,
                             type=socket.SOCK_DGRAM,
                             proto=socket.IPPROTO_UDP)
        if self.reuseaddr:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported.&#39;)

        # If mc_group is specified, subscribe to it as a multicast group
        if self.mc_group:
            # set outgoing multicast interface
            #
            # NOTE: Can&#39;t use loopback device for this, otherwise IGMP packets
            #       never leave the system, and you never actually join the
            #       group.
            #
            if self.interface.startswith(&#39;127.&#39;) and not self.this_is_a_test:
                logging.warning(&#34;Can&#39;t use loopback device for joining multicast groups.  Make &#34;
                                &#34;sure your system&#39;s hostname does NOT resolve to something in &#34;
                                &#34;the 127.0.0.0/8 address block (e.g., localhost, 127.0.0.1), or &#34;
                                &#34;specify the interface to use by passing its IP address as the &#34;
                                &#34;`interface` parameter.  (You can ignore this message if you&#39;re &#34;
                                &#34;actually just doing loopback testing.)&#34;)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF,
                            socket.inet_aton(self.interface))

            # join the group via IGMP
            #
            # NOTE: Since these are both already encoded as binary by
            #       inet_aton(), we can just concatenate them.  Alternatively,
            #       could use struct.pack(&#34;4s4s&#34;, ...) to create a struct to
            #       pass into setsockopt()
            #
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP,
                            socket.inet_aton(self.mc_group) + socket.inet_aton(self.interface))

            # bind to mc_group:port
            sock.bind((self.mc_group, self.port))

        else:
            # broadcast or unicast, bind to specificed interface
            sock.bind((self.interface, self.port))

        return sock

    ############################
    def read(self):
        &#34;&#34;&#34;
        Read the next UDP packet.
        &#34;&#34;&#34;
        # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
        if not self.socket:
            self.socket = self._open_socket()
        if not self.socket:
            logging.error(&#39;UDPReader.read: unable to open UDP socket&#39;)
            return

        # Read datagrams until we get one that doesn&#39;t end with a FRAGMENT_MARKER
        record_buffer = b&#39;&#39;
        while True:
            try:
                record = self.socket.recv(READ_BUFFER_SIZE)
            except OSError as e:
                logging.error(&#39;UDPReader error: %s&#39;, str(e))
                return None
            logging.debug(&#39;UDPReader.read: received %d bytes&#39;, len(record))

            if record.endswith(FRAGMENT_MARKER):
                # UDPWriter fragmented this record because it was too large to
                # send as a single datagram
                logging.info(&#39;UDPrader.read: detected fragmented packet&#39;)
                record_buffer += record.rsplit(FRAGMENT_MARKER, maxsplit=1)[0]
                logging.debug(&#39;record_buffer: %s&#39;, record_buffer)
            else:
                record_buffer += record
                break

        # we&#39;ve got a whole record in our record_buffer, decode it

        # if eol == None, return the record as is
        if not self.eol:
            return self._decode_bytes(record_buffer)

        # otherwise split the record by the eol
        decoded_records = self._decode_bytes(record_buffer).rstrip(self.eol).split(self.eol)

        # if there was only one record, return just the first element in the
        # list, otherwise return the whole list.
        return decoded_records[0] if len(decoded_records) == 1 else decoded_records</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.udp_reader.UDPReader"><code class="flex name class">
<span>class <span class="ident">UDPReader</span></span>
<span>(</span><span>interface=None, port=None, mc_group=None, reuseaddr=False, reuseport=False, encoding='utf-8', encoding_errors='ignore', eol=None, this_is_a_test=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read UDP packets from network.</p>
<pre><code>interface    IP (or resolvable name) of interface to listen on.  None or ''
             will listen on INADDR_ANY (all interfaces).  If joining a
             multicast group and None or '' specified, this will default
             to whatever the system's hostname resolves to.  This IP should
             not be on the loopback network (OK for testing, but won't work
             in the real world).

port         Port to listen to for packets.  REQUIRED

mc_group     If specified, IP address of multicast group id to subscribe to.

reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  If
             you don't know you need this, don't enable it.

reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
             you don't know you need this, don't enable it.

encoding     'utf-8' by default. If empty or None, do not attempt any decoding
             and return raw bytes. Other possible encodings are listed in
             online documentation here:
             https://docs. python.org/3/library/codecs.html#standard-encodings

encoding_errors 'ignore' by default. Other error strategies are 'strict',
                'replace', and 'backslashreplace', described here:
                https://docs.python.org/3/howto/unicode.html#encodings

eol          split the record by the eol character if present.

this_is_a_test - If True, recognize that this is being called in a unittest, so
        don't output warnings about not using loopback addresses.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UDPReader(Reader):
    &#34;&#34;&#34;Read UDP packets from network.&#34;&#34;&#34;
    ############################
    def __init__(self, interface=None, port=None, mc_group=None,
                 reuseaddr=False, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;, eol=None,
                 this_is_a_test=False):
        &#34;&#34;&#34;
        ```
        interface    IP (or resolvable name) of interface to listen on.  None or &#39;&#39;
                     will listen on INADDR_ANY (all interfaces).  If joining a
                     multicast group and None or &#39;&#39; specified, this will default
                     to whatever the system&#39;s hostname resolves to.  This IP should
                     not be on the loopback network (OK for testing, but won&#39;t work
                     in the real world).

        port         Port to listen to for packets.  REQUIRED

        mc_group     If specified, IP address of multicast group id to subscribe to.

        reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding     &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                     and return raw bytes. Other possible encodings are listed in
                     online documentation here:
                     https://docs. python.org/3/library/codecs.html#standard-encodings

        encoding_errors &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                        &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                        https://docs.python.org/3/howto/unicode.html#encodings

        eol          split the record by the eol character if present.

        this_is_a_test - If True, recognize that this is being called in a unittest, so
                don&#39;t output warnings about not using loopback addresses.
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if interface:
            # resolve once in constructor
            interface = socket.gethostbyname(interface)
        else:
            interface = &#39;&#39;
        self.interface = interface

        # make sure user passed in `port`
        #
        # NOTE: We want the order of the arguments to consistently be (ip,
        #       port, ...) across all the network readers/writers... but we
        #       want `interface` to be optional.  All kwargs need to come after
        #       all regular args, so we&#39;ve assigned a default value of None to
        #       `port`.  But don&#39;t be confused, it is REQUIRED.
        #
        if not port:
            raise TypeError(&#39;must specify `port`&#39;)
        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        # prep multicast parameters
        if mc_group:
            # resolve once in constructor
            mc_group = socket.gethostbyname(mc_group)
            if not interface:
                # multicast needs to specify interface to use, so let&#39;s pick a
                # sane default
                #
                # NOTE: This means hostname cannot be an alias to localhost, or
                #       you won&#39;t be able to send IGMP packets correctly.
                #
                self.interface = socket.gethostbyname(socket.gethostname())

        self.mc_group = mc_group

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        self.eol = eol

        self.this_is_a_test = this_is_a_test

        # socket gets initialized on-demand in read()
        self.socket = None

    ############################
    def __del__(self):
        if self.socket:
            self.socket.close()

    ############################
    def _open_socket(self):
        &#34;&#34;&#34;Do socket prep so we&#39;re ready to read().  Returns socket object or None on
        failure.
        &#34;&#34;&#34;
        sock = socket.socket(family=socket.AF_INET,
                             type=socket.SOCK_DGRAM,
                             proto=socket.IPPROTO_UDP)
        if self.reuseaddr:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported.&#39;)

        # If mc_group is specified, subscribe to it as a multicast group
        if self.mc_group:
            # set outgoing multicast interface
            #
            # NOTE: Can&#39;t use loopback device for this, otherwise IGMP packets
            #       never leave the system, and you never actually join the
            #       group.
            #
            if self.interface.startswith(&#39;127.&#39;) and not self.this_is_a_test:
                logging.warning(&#34;Can&#39;t use loopback device for joining multicast groups.  Make &#34;
                                &#34;sure your system&#39;s hostname does NOT resolve to something in &#34;
                                &#34;the 127.0.0.0/8 address block (e.g., localhost, 127.0.0.1), or &#34;
                                &#34;specify the interface to use by passing its IP address as the &#34;
                                &#34;`interface` parameter.  (You can ignore this message if you&#39;re &#34;
                                &#34;actually just doing loopback testing.)&#34;)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_IF,
                            socket.inet_aton(self.interface))

            # join the group via IGMP
            #
            # NOTE: Since these are both already encoded as binary by
            #       inet_aton(), we can just concatenate them.  Alternatively,
            #       could use struct.pack(&#34;4s4s&#34;, ...) to create a struct to
            #       pass into setsockopt()
            #
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP,
                            socket.inet_aton(self.mc_group) + socket.inet_aton(self.interface))

            # bind to mc_group:port
            sock.bind((self.mc_group, self.port))

        else:
            # broadcast or unicast, bind to specificed interface
            sock.bind((self.interface, self.port))

        return sock

    ############################
    def read(self):
        &#34;&#34;&#34;
        Read the next UDP packet.
        &#34;&#34;&#34;
        # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
        if not self.socket:
            self.socket = self._open_socket()
        if not self.socket:
            logging.error(&#39;UDPReader.read: unable to open UDP socket&#39;)
            return

        # Read datagrams until we get one that doesn&#39;t end with a FRAGMENT_MARKER
        record_buffer = b&#39;&#39;
        while True:
            try:
                record = self.socket.recv(READ_BUFFER_SIZE)
            except OSError as e:
                logging.error(&#39;UDPReader error: %s&#39;, str(e))
                return None
            logging.debug(&#39;UDPReader.read: received %d bytes&#39;, len(record))

            if record.endswith(FRAGMENT_MARKER):
                # UDPWriter fragmented this record because it was too large to
                # send as a single datagram
                logging.info(&#39;UDPrader.read: detected fragmented packet&#39;)
                record_buffer += record.rsplit(FRAGMENT_MARKER, maxsplit=1)[0]
                logging.debug(&#39;record_buffer: %s&#39;, record_buffer)
            else:
                record_buffer += record
                break

        # we&#39;ve got a whole record in our record_buffer, decode it

        # if eol == None, return the record as is
        if not self.eol:
            return self._decode_bytes(record_buffer)

        # otherwise split the record by the eol
        decoded_records = self._decode_bytes(record_buffer).rstrip(self.eol).split(self.eol)

        # if there was only one record, return just the first element in the
        # list, otherwise return the whole list.
        return decoded_records[0] if len(decoded_records) == 1 else decoded_records</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.readers.udp_reader.UDPReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the next UDP packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    &#34;&#34;&#34;
    Read the next UDP packet.
    &#34;&#34;&#34;
    # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
    if not self.socket:
        self.socket = self._open_socket()
    if not self.socket:
        logging.error(&#39;UDPReader.read: unable to open UDP socket&#39;)
        return

    # Read datagrams until we get one that doesn&#39;t end with a FRAGMENT_MARKER
    record_buffer = b&#39;&#39;
    while True:
        try:
            record = self.socket.recv(READ_BUFFER_SIZE)
        except OSError as e:
            logging.error(&#39;UDPReader error: %s&#39;, str(e))
            return None
        logging.debug(&#39;UDPReader.read: received %d bytes&#39;, len(record))

        if record.endswith(FRAGMENT_MARKER):
            # UDPWriter fragmented this record because it was too large to
            # send as a single datagram
            logging.info(&#39;UDPrader.read: detected fragmented packet&#39;)
            record_buffer += record.rsplit(FRAGMENT_MARKER, maxsplit=1)[0]
            logging.debug(&#39;record_buffer: %s&#39;, record_buffer)
        else:
            record_buffer += record
            break

    # we&#39;ve got a whole record in our record_buffer, decode it

    # if eol == None, return the record as is
    if not self.eol:
        return self._decode_bytes(record_buffer)

    # otherwise split the record by the eol
    decoded_records = self._decode_bytes(record_buffer).rstrip(self.eol).split(self.eol)

    # if there was only one record, return just the first element in the
    # list, otherwise return the whole list.
    return decoded_records[0] if len(decoded_records) == 1 else decoded_records</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.reader.Reader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.udp_reader.UDPReader" href="#logger.readers.udp_reader.UDPReader">UDPReader</a></code></h4>
<ul class="">
<li><code><a title="logger.readers.udp_reader.UDPReader.read" href="#logger.readers.udp_reader.UDPReader.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>