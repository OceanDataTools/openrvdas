<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>logger.readers.tcp_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.tcp_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import mmap
import socket
import sys

from os.path import dirname, realpath
sys.path.append(dirname(dirname(dirname(realpath(__file__)))))
from logger.readers.reader import Reader  # noqa: E402

# the size of each recv() call in read_to_eol()
#
# NOTE: Optimal value should be the system&#39;s page size, which is probably 4k.
#
READ_BUFFER_SIZE = mmap.PAGESIZE


################################################################################
class TCPReader(Reader):
    &#34;&#34;&#34; Read TCP packets from network.&#34;&#34;&#34;
    ############################
    def __init__(self, interface=None, port=None, eol=None,
                 reuseaddr=True, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        ```
        interface    IP (or resolvable name) of interface to listen on.  None or &#39;&#39;
                     will listen on INADDR_ANY (all interfaces).

        port         Port to listen to for packets.  REQUIRED

        eol          If specified, buffer network reads until the `eol` sequence has
                     been seen, and return the entire record at once.  In other words,
                     present the user with a very UDP-ish 1 read gives you 1 whole
                     record feel, even though this is TCP.  If not specified, read()
                     calls must specify read sizes and it&#39;s up to the user to
                     control the TCP stream.

        reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  This
                     is enabled by default (unlike TCPWriter, UDPWriter, or UDPReader)
                     specifically to avoid leftover TIME_WAIT sockets from
                     interferring with startup.

        reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if interface:
            # resolve once in constructor
            interface = socket.gethostbyname(interface)
        else:
            interface = &#39;&#39;
        self.interface = interface

        # make sure user passed in `port`
        #
        # NOTE: We want the order of the arguments to consistently be (ip,
        #       port, ...) across all the network readers/writers... but we
        #       want `interface` to be optional.  All kwargs need to come after
        #       all regular args, so we&#39;ve assigned a default value of None to
        #       `port`.  But don&#39;t be confused, it is REQUIRED.
        #
        if not port:
            raise TypeError(&#39;must specify `port`&#39;)
        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        # prep eol
        #
        # NOTE: We&#39;re going to be looking for `eol` inside of the byte array
        #       returned by recv(), so it has to be encoded to bytes here
        #       regardless of `encoding`.
        #
        # NOTE: We set unescape to True because `eol` might be provided w/
        #       escaped out characters
        #
        if eol:
            eol = self._encode_str(eol, unescape=True)
        self.eol = eol

        # Where we&#39;ll aggregate incomplete records if an eol char is specified
        self.record_buffer = b&#39;&#39;

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        # initialize this now, so our socket is ready to accept connections
        # once constructed
        self.s_listening = self._open_socket()

        # these get set when we successfully accept() an incoming connection in read()
        self.s_connected = None
        self.client_addr = None

    ############################
    def __del__(self):
        if self.s_connected:
            logging.debug(&#39;__del__: closing s_connected&#39;)
            self._close_socket(self.s_connected)

    ############################
    def _open_socket(self):
        # create TCP socket
        s = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP)

        # set sockopts
        if self.reuseaddr:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported.&#39;)

        # bind to specificed interface
        s.bind((self.interface, self.port))

        # start listening
        s.listen()

        return s

    ############################
    def _close_socket(self, s):
        s.shutdown(socket.SHUT_RDWR)
        s.close()

    ############################
    def _get_connected_socket(self):
        # make sure we&#39;re already listening
        if not self.s_listening:
            self.s_listening = self._open_socket()
        if not self.s_listening:
            logging.error(&#34;failed to open socket&#34;)
            return

        # accept connections
        #
        # NOTE: This will block until we have an incoming connection.
        #
        s_connected, client_addr = self.s_listening.accept()
        logging.debug(&#39;got connection from %s&#39;, client_addr)
        return s_connected, client_addr

    ############################
    def _read_size(self, size):
        try:
            # NOTE: This will block until there is *something* to return, but
            #       it won&#39;t wait for the full `size` before returning.
            record = self.s_connected.recv(size)
            # catch disconnected socket
            #
            # NOTE: If remote side disconnects, recv() &#34;successfully&#34; returns 0
            #       bytes.  We have to turn that into a failure so we
            #       re-establish comms before trying to recv() again.
            #
            if len(record) == 0:
                raise OSError(&#34;socket disconneced&#34;)
        except OSError as e:
            logging.error(&#39;TCPReader recv error: %s&#39;, str(e))
            # nuke the socket so we reconnect on next read()
            self._close_socket(self.s_connected)
            self.s_connected = None
            return None
        logging.debug(&#39;TCPReader._read_size: received %d bytes&#39;, len(record))
        return record

    ############################
    def _read_to_eol(self):
        while self.eol not in self.record_buffer:
            try:
                record = self.s_connected.recv(READ_BUFFER_SIZE)
                # catch disconnected socket
                #
                # NOTE: If remote side disconnects, recv() &#34;successfully&#34;
                #       returns 0 bytes.  We have to turn that into a failure
                #       so we re-establish comms before trying to recv() again.
                #
                if len(record) == 0:
                    raise OSError(&#34;socket disconneced&#34;)
            except OSError as e:
                logging.error(&#39;TCPReader recv error: %s&#39;, str(e))
                # nuke the socket so we reconnect on next read()
                self._close_socket(self.s_connected)
                self.s_connected = None
                return None
            logging.debug(&#39;TCPReader._read_to_eol: received %d bytes&#39;, len(record))

            self.record_buffer += record

        # we&#39;ve got `eol` in our buffer, split out the first record
        i = self.record_buffer.find(self.eol)
        # `i` is the index of the BEGINNING of our `eol` sequence
        record = self.record_buffer[:i]
        # beginning of NEXT message is at i+len(eol)
        self.record_buffer = self.record_buffer[i+len(self.eol):]
        return record

    ############################
    def read(self, size=None):
        &#34;&#34;&#34;Read from TCP socket, either up to the next `eol` in the stream or up to
        `size` bytes (ignoring `eol` even if set!), return the result.
        &#34;&#34;&#34;
        # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
        if not self.s_connected:
            self.s_connected, self.client_addr = self._get_connected_socket()
        if not self.s_connected:
            logging.error(&#39;TCPReader.read: unable to get connected socket&#39;)
            return

        if size:
            record = self._read_size(size)
        elif self.eol:
            record = self._read_to_eol()
        else:
            # invalid, need `eol` or `size`
            logging.error(&#39;need either `eol` or `size`&#39;)
            return

        record = self._decode_bytes(record)
        return record</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.tcp_reader.TCPReader"><code class="flex name class">
<span>class <span class="ident">TCPReader</span></span>
<span>(</span><span>interface=None, port=None, eol=None, reuseaddr=True, reuseport=False, encoding='utf-8', encoding_errors='ignore')</span>
</code></dt>
<dd>
<div class="desc"><p>Read TCP packets from network.</p>
<pre><code>interface    IP (or resolvable name) of interface to listen on.  None or ''
             will listen on INADDR_ANY (all interfaces).

port         Port to listen to for packets.  REQUIRED

eol          If specified, buffer network reads until the `eol` sequence has
             been seen, and return the entire record at once.  In other words,
             present the user with a very UDP-ish 1 read gives you 1 whole
             record feel, even though this is TCP.  If not specified, read()
             calls must specify read sizes and it's up to the user to
             control the TCP stream.

reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  This
             is enabled by default (unlike TCPWriter, UDPWriter, or UDPReader)
             specifically to avoid leftover TIME_WAIT sockets from
             interferring with startup.

reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
             you don't know you need this, don't enable it.

encoding - 'utf-8' by default. If empty or None, do not attempt any decoding
        and return raw bytes. Other possible encodings are listed in online
        documentation here:
        https://docs.python.org/3/library/codecs.html#standard-encodings

encoding_errors - 'ignore' by default. Other error strategies are 'strict',
        'replace', and 'backslashreplace', described here:
        https://docs.python.org/3/howto/unicode.html#encodings
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TCPReader(Reader):
    &#34;&#34;&#34; Read TCP packets from network.&#34;&#34;&#34;
    ############################
    def __init__(self, interface=None, port=None, eol=None,
                 reuseaddr=True, reuseport=False,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;):
        &#34;&#34;&#34;
        ```
        interface    IP (or resolvable name) of interface to listen on.  None or &#39;&#39;
                     will listen on INADDR_ANY (all interfaces).

        port         Port to listen to for packets.  REQUIRED

        eol          If specified, buffer network reads until the `eol` sequence has
                     been seen, and return the entire record at once.  In other words,
                     present the user with a very UDP-ish 1 read gives you 1 whole
                     record feel, even though this is TCP.  If not specified, read()
                     calls must specify read sizes and it&#39;s up to the user to
                     control the TCP stream.

        reuseaddr    Specifies wether we set SO_REUSEADDR on the created socket.  This
                     is enabled by default (unlike TCPWriter, UDPWriter, or UDPReader)
                     specifically to avoid leftover TIME_WAIT sockets from
                     interferring with startup.

        reuseport    Specifies wether we set SO_REUSEPORT on the created socket.  If
                     you don&#39;t know you need this, don&#39;t enable it.

        encoding - &#39;utf-8&#39; by default. If empty or None, do not attempt any decoding
                and return raw bytes. Other possible encodings are listed in online
                documentation here:
                https://docs.python.org/3/library/codecs.html#standard-encodings

        encoding_errors - &#39;ignore&#39; by default. Other error strategies are &#39;strict&#39;,
                &#39;replace&#39;, and &#39;backslashreplace&#39;, described here:
                https://docs.python.org/3/howto/unicode.html#encodings
        ```
        &#34;&#34;&#34;
        super().__init__(encoding=encoding,
                         encoding_errors=encoding_errors)

        if interface:
            # resolve once in constructor
            interface = socket.gethostbyname(interface)
        else:
            interface = &#39;&#39;
        self.interface = interface

        # make sure user passed in `port`
        #
        # NOTE: We want the order of the arguments to consistently be (ip,
        #       port, ...) across all the network readers/writers... but we
        #       want `interface` to be optional.  All kwargs need to come after
        #       all regular args, so we&#39;ve assigned a default value of None to
        #       `port`.  But don&#39;t be confused, it is REQUIRED.
        #
        if not port:
            raise TypeError(&#39;must specify `port`&#39;)
        # make sure port gets stored as an int, even if passed in as a string
        self.port = int(port)

        # prep eol
        #
        # NOTE: We&#39;re going to be looking for `eol` inside of the byte array
        #       returned by recv(), so it has to be encoded to bytes here
        #       regardless of `encoding`.
        #
        # NOTE: We set unescape to True because `eol` might be provided w/
        #       escaped out characters
        #
        if eol:
            eol = self._encode_str(eol, unescape=True)
        self.eol = eol

        # Where we&#39;ll aggregate incomplete records if an eol char is specified
        self.record_buffer = b&#39;&#39;

        self.reuseaddr = reuseaddr
        self.reuseport = reuseport

        # initialize this now, so our socket is ready to accept connections
        # once constructed
        self.s_listening = self._open_socket()

        # these get set when we successfully accept() an incoming connection in read()
        self.s_connected = None
        self.client_addr = None

    ############################
    def __del__(self):
        if self.s_connected:
            logging.debug(&#39;__del__: closing s_connected&#39;)
            self._close_socket(self.s_connected)

    ############################
    def _open_socket(self):
        # create TCP socket
        s = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP)

        # set sockopts
        if self.reuseaddr:
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        if self.reuseport:
            try:  # Raspbian doesn&#39;t recognize SO_REUSEPORT
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
            except AttributeError:
                logging.warning(&#39;Unable to set socket REUSEPORT; may be unsupported.&#39;)

        # bind to specificed interface
        s.bind((self.interface, self.port))

        # start listening
        s.listen()

        return s

    ############################
    def _close_socket(self, s):
        s.shutdown(socket.SHUT_RDWR)
        s.close()

    ############################
    def _get_connected_socket(self):
        # make sure we&#39;re already listening
        if not self.s_listening:
            self.s_listening = self._open_socket()
        if not self.s_listening:
            logging.error(&#34;failed to open socket&#34;)
            return

        # accept connections
        #
        # NOTE: This will block until we have an incoming connection.
        #
        s_connected, client_addr = self.s_listening.accept()
        logging.debug(&#39;got connection from %s&#39;, client_addr)
        return s_connected, client_addr

    ############################
    def _read_size(self, size):
        try:
            # NOTE: This will block until there is *something* to return, but
            #       it won&#39;t wait for the full `size` before returning.
            record = self.s_connected.recv(size)
            # catch disconnected socket
            #
            # NOTE: If remote side disconnects, recv() &#34;successfully&#34; returns 0
            #       bytes.  We have to turn that into a failure so we
            #       re-establish comms before trying to recv() again.
            #
            if len(record) == 0:
                raise OSError(&#34;socket disconneced&#34;)
        except OSError as e:
            logging.error(&#39;TCPReader recv error: %s&#39;, str(e))
            # nuke the socket so we reconnect on next read()
            self._close_socket(self.s_connected)
            self.s_connected = None
            return None
        logging.debug(&#39;TCPReader._read_size: received %d bytes&#39;, len(record))
        return record

    ############################
    def _read_to_eol(self):
        while self.eol not in self.record_buffer:
            try:
                record = self.s_connected.recv(READ_BUFFER_SIZE)
                # catch disconnected socket
                #
                # NOTE: If remote side disconnects, recv() &#34;successfully&#34;
                #       returns 0 bytes.  We have to turn that into a failure
                #       so we re-establish comms before trying to recv() again.
                #
                if len(record) == 0:
                    raise OSError(&#34;socket disconneced&#34;)
            except OSError as e:
                logging.error(&#39;TCPReader recv error: %s&#39;, str(e))
                # nuke the socket so we reconnect on next read()
                self._close_socket(self.s_connected)
                self.s_connected = None
                return None
            logging.debug(&#39;TCPReader._read_to_eol: received %d bytes&#39;, len(record))

            self.record_buffer += record

        # we&#39;ve got `eol` in our buffer, split out the first record
        i = self.record_buffer.find(self.eol)
        # `i` is the index of the BEGINNING of our `eol` sequence
        record = self.record_buffer[:i]
        # beginning of NEXT message is at i+len(eol)
        self.record_buffer = self.record_buffer[i+len(self.eol):]
        return record

    ############################
    def read(self, size=None):
        &#34;&#34;&#34;Read from TCP socket, either up to the next `eol` in the stream or up to
        `size` bytes (ignoring `eol` even if set!), return the result.
        &#34;&#34;&#34;
        # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
        if not self.s_connected:
            self.s_connected, self.client_addr = self._get_connected_socket()
        if not self.s_connected:
            logging.error(&#39;TCPReader.read: unable to get connected socket&#39;)
            return

        if size:
            record = self._read_size(size)
        elif self.eol:
            record = self._read_to_eol()
        else:
            # invalid, need `eol` or `size`
            logging.error(&#39;need either `eol` or `size`&#39;)
            return

        record = self._decode_bytes(record)
        return record</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.readers.tcp_reader.TCPReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read from TCP socket, either up to the next <code>eol</code> in the stream or up to
<code>size</code> bytes (ignoring <code>eol</code> even if set!), return the result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, size=None):
    &#34;&#34;&#34;Read from TCP socket, either up to the next `eol` in the stream or up to
    `size` bytes (ignoring `eol` even if set!), return the result.
    &#34;&#34;&#34;
    # If socket isn&#39;t ready, set it up.  If something fails, return w/out reading.
    if not self.s_connected:
        self.s_connected, self.client_addr = self._get_connected_socket()
    if not self.s_connected:
        logging.error(&#39;TCPReader.read: unable to get connected socket&#39;)
        return

    if size:
        record = self._read_size(size)
    elif self.eol:
        record = self._read_to_eol()
    else:
        # invalid, need `eol` or `size`
        logging.error(&#39;need either `eol` or `size`&#39;)
        return

    record = self._decode_bytes(record)
    return record</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.reader.Reader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.tcp_reader.TCPReader" href="#logger.readers.tcp_reader.TCPReader">TCPReader</a></code></h4>
<ul class="">
<li><code><a title="logger.readers.tcp_reader.TCPReader.read" href="#logger.readers.tcp_reader.TCPReader.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>