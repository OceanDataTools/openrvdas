<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>logger.readers.polled_serial_reader API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.polled_serial_reader</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="logger.readers.polled_serial_reader.is_dict_of_lists_of_strings"><code class="name flex">
<span>def <span class="ident">is_dict_of_lists_of_strings</span></span>(<span>cmd)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_dict_of_lists_of_strings(cmd):
    if not isinstance(cmd, dict):
        return False

    # So we have a dict. Check that all values are either strings
    # or lists of strings
    for value in cmd.values():
        if isinstance(value, str):
            continue
        elif (isinstance(value, list) and
              all(isinstance(item, str) for item in value)):
            continue
        else:
            return False

    # If got this far, it all checks out
    return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="logger.readers.polled_serial_reader.is_string_or_list_of_strings"><code class="name flex">
<span>def <span class="ident">is_string_or_list_of_strings</span></span>(<span>cmd)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_string_or_list_of_strings(cmd):
    if isinstance(cmd, str):
        return True
    elif isinstance(cmd, list):
        return all(isinstance(item, str) for item in cmd)
    return False</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.polled_serial_reader.PolledSerialReader"><code class="flex name class">
<span>class <span class="ident">PolledSerialReader</span></span>
<span>(</span><span>port,<br>baudrate=9600,<br>bytesize=8,<br>parity='N',<br>stopbits=1,<br>timeout=None,<br>xonxoff=False,<br>rtscts=False,<br>write_timeout=None,<br>dsrdtr=False,<br>inter_byte_timeout=None,<br>exclusive=None,<br>max_bytes=None,<br>eol=None,<br>encoding='utf-8',<br>encoding_errors='ignore',<br>start_cmd=None,<br>pre_read_cmd=None,<br>stop_cmd=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolledSerialReader(SerialReader):
    &#34;&#34;&#34;
    Read text records from a serial port.
    &#34;&#34;&#34;

    def __init__(self,  port, baudrate=9600, bytesize=8, parity=&#39;N&#39;,
                 stopbits=1, timeout=None, xonxoff=False, rtscts=False,
                 write_timeout=None, dsrdtr=False, inter_byte_timeout=None,
                 exclusive=None, max_bytes=None, eol=None,
                 encoding=&#39;utf-8&#39;, encoding_errors=&#39;ignore&#39;,
                 start_cmd=None, pre_read_cmd=None, stop_cmd=None):
        &#34;&#34;&#34;Extends the standard serial reader by allowing the user to define
        strings to send to the serial host on startup, before each read and
        just prior to the reader being destroyed.

        Notable arguments:
        ```
        start_cmd
            If not None, may be string or list of strings. If a single string,
            it is sent to the serial port as soon as it is opened. If a list of
            strings, each string in the list is sent in sequence.

        stop_cmd
            Much as start_cmd, but is sent when the PolledSerialReader is closed
            or destroyed.

        pre_read_cmd
            Much as start_cmd and stop_cmd, except the string or list of strings
            are sent each time the PolledSerialReader&#39;s read() method is called,
            prior to trying to read from the port.

            In addition to a string or list of strings, pre_read_cmd may be a *dict*
            of lists of strings:

                pre_read_cmd:
                  key1: [&#39;command 1_1&#39;, &#39;command 1_2]
                  key2: [&#39;command 2_1&#39;, &#39;command 2_2]
                  key3: ...
                ...
            The first time read() is called, the strings associated with key1 will be
            sent. The second time, those associated with key2, and so on. When the end
            of the dict is reached, it will start again with key1.

        timeout &lt;seconds&gt;
            If timeout is specified, then the serial read will time out after this many
            seconds. It will then reissue the pre_read_cmds, if there is one, and try
            reading again. If there is a dict of pre_read_cmds, it will progress to the
            next one in the dict.
        ```
        For all of these arguments, a special string, ``__PAUSE__``, is recognized. If
        followed by a number (e.g. ``__PAUSE__ 5``), it will be interpreted as a command
        to pause for that many seconds prior to sending the next command. If no number
        is given, it will pause for one second.
        &#34;&#34;&#34;
        self.start_cmd = start_cmd
        self.pre_read_cmd = pre_read_cmd
        self.stop_cmd = stop_cmd

        # Type check our pre_read commands
        if start_cmd and not is_string_or_list_of_strings(start_cmd):
            raise ValueError(&#39;PolledSerialReader start_cmd must either be None, &#39;
                             f&#39;a string, or a list of strings. Found: {start_cmd}&#39;)
        if stop_cmd and not is_string_or_list_of_strings(stop_cmd):
            raise ValueError(&#39;PolledSerialReader stop_cmd must either be None, &#39;
                             f&#39;a string, or a list of strings. Found: {stop_cmd}&#39;)
        if pre_read_cmd and not (is_string_or_list_of_strings(pre_read_cmd) or
                                 is_dict_of_lists_of_strings(pre_read_cmd)):
            raise ValueError(&#39;PolledSerialReader pre_read_cmd must either be None, &#39;
                             &#39;a string, or a list of strings, or a dict of lists of &#39;
                             f&#39;strings. Found: {pre_read_cmd}&#39;)

        if isinstance(pre_read_cmd, dict):
            self.command_cycle = cycle(pre_read_cmd.items())

        super().__init__(port=port, baudrate=baudrate, bytesize=bytesize,
                         parity=parity, stopbits=stopbits, timeout=timeout,
                         xonxoff=xonxoff, rtscts=rtscts, write_timeout=write_timeout,
                         dsrdtr=dsrdtr, inter_byte_timeout=inter_byte_timeout,
                         exclusive=exclusive, max_bytes=max_bytes, eol=eol,
                         encoding=encoding, encoding_errors=encoding_errors)
        if not SERIAL_MODULE_FOUND:
            raise RuntimeError(&#39;Serial port functionality not available. Please &#39;
                               &#39;install Python module pyserial.&#39;)
        if self.start_cmd:
            try:
                if isinstance(self.start_cmd, list):  # list of commands
                    for cmd in self.start_cmd:
                        self._send_command(cmd)
                else:
                    self._send_command(start_cmd)
            except serial.serialutil.SerialException as e:
                logging.error(str(e))

    ############################
    def _send_command(self, cmd):
        &#34;&#34;&#34;Check if command is a &#39;pause&#39;; if so, sleep, otherwise send it to serial port.&#34;&#34;&#34;
        logging.debug(f&#39;Sending {cmd}&#39;)
        if cmd.find(&#39;__PAUSE__&#39;) == 0:
            pause_cmd = cmd.split()
            if len(pause_cmd) == 1:
                pause_length = 1
            elif len(pause_cmd) == 2:
                try:
                    pause_length = float(pause_cmd[1])
                except ValueError:
                    raise ValueError(&#39;__PAUSE__ interval in PolledSerialReader must be &#39;
                                     &#39;a float. Found: %s&#39; % cmd)
            else:
                raise ValueError(&#39;Pause format &#34;__PAUSE__ &lt;seconds&gt;&#34;; found %s&#39; % cmd)
            logging.info(&#39;Pausing %g seconds&#39;, pause_length)
            time.sleep(pause_length)
        else:
            # If it&#39;s a normal command we&#39;re sending
            logging.info(&#39;Sending serial command &#34;%s&#34;&#39;, cmd)
            self.serial.write(self._encode_str(cmd, unescape=True))
            self.serial.flush()

        logging.debug(f&#39;Done sending {cmd}&#39;)

    ############################
    def read(self):
        try:
            # Try again if our read times out, or our serial port returns None
            while True:
                # Do we need to send anything prior to reading?
                if not self.pre_read_cmd:  # no pre_read_cmd
                    pass
                elif isinstance(self.pre_read_cmd, list):  # list of commands
                    for cmd in self.pre_read_cmd:
                        self._send_command(cmd)
                elif isinstance(self.pre_read_cmd, dict):  # dict of lists of commands
                    key, commands = next(self.command_cycle)
                    for cmd in commands:
                        self._send_command(cmd)
                elif self.pre_read_cmd:   # simple string command
                    self._send_command(self.pre_read_cmd)

                logging.debug(&#39;read() is being called&#39;)
                record = super().read()
                logging.debug(f&#39;Returned from read() with: {record}&#39;)
                if record is not None:
                    return record
                logging.debug(&#39;Serial read returned None; trying again.&#39;)

        except serial.serialutil.SerialException as e:
            logging.error(str(e))
            return None

    ############################
    def __del__(self):
        if self.stop_cmd:
            try:
                if isinstance(self.stop_cmd, list):  # list of commands
                    for cmd in self.stop_cmd:
                        self._send_command(cmd)
                else:
                    self._send_command(self.stop_cmd)
            except serial.serialutil.SerialException as e:
                logging.error(str(e))</code></pre>
</details>
<div class="desc"><p>Read text records from a serial port.</p>
<p>Extends the standard serial reader by allowing the user to define
strings to send to the serial host on startup, before each read and
just prior to the reader being destroyed.</p>
<p>Notable arguments:</p>
<pre><code>start_cmd
    If not None, may be string or list of strings. If a single string,
    it is sent to the serial port as soon as it is opened. If a list of
    strings, each string in the list is sent in sequence.

stop_cmd
    Much as start_cmd, but is sent when the PolledSerialReader is closed
    or destroyed.

pre_read_cmd
    Much as start_cmd and stop_cmd, except the string or list of strings
    are sent each time the PolledSerialReader's read() method is called,
    prior to trying to read from the port.

    In addition to a string or list of strings, pre_read_cmd may be a *dict*
    of lists of strings:

        pre_read_cmd:
          key1: ['command 1_1', 'command 1_2]
          key2: ['command 2_1', 'command 2_2]
          key3: ...
        ...
    The first time read() is called, the strings associated with key1 will be
    sent. The second time, those associated with key2, and so on. When the end
    of the dict is reached, it will start again with key1.

timeout &lt;seconds&gt;
    If timeout is specified, then the serial read will time out after this many
    seconds. It will then reissue the pre_read_cmds, if there is one, and try
    reading again. If there is a dict of pre_read_cmds, it will progress to the
    next one in the dict.
</code></pre>
<p>For all of these arguments, a special string, <code>__PAUSE__</code>, is recognized. If
followed by a number (e.g. <code>__PAUSE__ 5</code>), it will be interpreted as a command
to pause for that many seconds prior to sending the next command. If no number
is given, it will pause for one second.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.serial_reader.SerialReader" href="serial_reader.html#logger.readers.serial_reader.SerialReader">SerialReader</a></li>
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.serial_reader.SerialReader" href="serial_reader.html#logger.readers.serial_reader.SerialReader">SerialReader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.serial_reader.SerialReader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
<li><code><a title="logger.readers.serial_reader.SerialReader.read" href="reader.html#logger.readers.reader.Reader.read">read</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="logger.readers.polled_serial_reader.is_dict_of_lists_of_strings" href="#logger.readers.polled_serial_reader.is_dict_of_lists_of_strings">is_dict_of_lists_of_strings</a></code></li>
<li><code><a title="logger.readers.polled_serial_reader.is_string_or_list_of_strings" href="#logger.readers.polled_serial_reader.is_string_or_list_of_strings">is_string_or_list_of_strings</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.polled_serial_reader.PolledSerialReader" href="#logger.readers.polled_serial_reader.PolledSerialReader">PolledSerialReader</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
