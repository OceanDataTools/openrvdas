<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>logger.readers.network_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>logger.readers.network_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import logging
import socket
import sys

from os.path import dirname, realpath; sys.path.append(dirname(dirname(dirname(realpath(__file__)))))

from logger.utils.formats import Text
from logger.readers.reader import Reader

READ_BUFFER_SIZE = 4096 # max number of characters to read in one call

################################################################################
# Read to the specified file. If filename is empty, read to stdout.
class NetworkReader(Reader):
  &#34;&#34;&#34;
  Read text records from a network socket.

  NOTE: tcp is nominally implemented, but DOES NOT WORK!

  TODO: code won&#39;t handle records that are larger than 4K right now,
  which, if we start getting into Toby Martin&#39;s Total Metadata Ingestion
  (TMI), may not be enough. We&#39;ll need to implement something that will
  aggregate recv()&#39;s and know when it&#39;s got an entire record?
  &#34;&#34;&#34;
  ############################
  def __init__(self, network, eol=None, read_buffer_size=READ_BUFFER_SIZE):
    &#34;&#34;&#34;
    ```
    network      Network address to read, in host:port format (e.g.
                 &#39;rvdas:6202&#39;). If host is omitted (e.g. &#39;:6202&#39;),
                 read via UDP on specified port.

    eol          If not specified, assume one record per network packet.  If
                 specified, buffer network reads until the eol
                 character has been seen, and return the entire record
                 at once, retaining everything after the eol for the
                 start of the subsequent record. If multiple eol characters
                 are encountered in a packet, split the packet and return
                 the first of them, buffering the remainder for subsequent
                 calls.
    ```
    &#34;&#34;&#34;
    super().__init__(output_format=Text)

    self.network = network
    self.eol = eol
    self.read_buffer_size = read_buffer_size

    # Where we&#39;ll aggregate incomplete records if an eol char is specified
    self.record_buffer = &#39;&#39;

    if network.find(&#39;:&#39;) == -1:
      raise ValueError(&#39;NetworkReader network argument must be in \&#39;host:port\&#39;&#39;
                       &#39; or \&#39;:port\&#39; format. Found &#34;%s&#34;&#39; % network)
    (host, port) = network.split(&#39;:&#39;)
    port = int(port)

    # TCP if host is specified
    if host:
      self.socket = socket.socket(family=socket.AF_INET,
                                  type=socket.SOCK_STREAM,
                                  proto=socket.IPPROTO_TCP)
      # Should this be bind()?
      self.socket.connect((host, port))

    # UDP broadcast if no host specified. Note that there&#39;s some
    # dodginess I don&#39;t understand about networks: if &#39;&lt;broadcast&gt;&#39; is
    # specified, socket tries to send on *all* interfaces. if &#39;&#39; is
    # specified, it tries to send on *any* interface.
    else:
      host = &#39;&#39; # special code for broadcast
      self.socket = socket.socket(family=socket.AF_INET,
                                  type=socket.SOCK_DGRAM,
                                  proto=socket.IPPROTO_UDP)
      self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)
      try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
      except AttributeError:
        logging.warning(&#39;Unable to set socket REUSEPORT; system may not support it.&#39;)
      self.socket.bind((host, port))

  ############################
  def read(self):
    &#34;&#34;&#34;
    Read the next network packet.
    &#34;&#34;&#34;
    # If no eol character/string specified, just read a packet and
    # return it as the next record.
    if not self.eol:
      record = self.socket.recv(self.read_buffer_size)
      logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
      if record:
        record = record.decode(&#39;utf-8&#39;)
      return record

    # If an eol character/string has been specified, we may have to
    # loop our reads until we see an eol.
    while True:
      eol_pos = self.record_buffer.rfind(self.eol)
      if eol_pos &gt; -1:
        logging.debug(&#39;NetworkReader found eol; returning record&#39;)

        # We have an eol string somewhere in our buffer. Extract
        # everything up to the last eol and split up by eol&#39;s.
        record_end = eol_pos + len(self.eol)
        record = self.record_buffer[0:eol_pos].split(self.eol)
        self.record_buffer = self.record_buffer[record_end:]

        # If we only have one record in list, return it as a string,
        # otherwise return as list of strings.
        if len(record) == 1:
          record = record[0]          
        return record

      # If no eol string, read, append, and try again.
      record = self.socket.recv(self.read_buffer_size)
      logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
      if record:
        self.record_buffer += record.decode(&#39;utf-8&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="logger.readers.network_reader.NetworkReader"><code class="flex name class">
<span>class <span class="ident">NetworkReader</span></span>
<span>(</span><span>network, eol=None, read_buffer_size=4096)</span>
</code></dt>
<dd>
<div class="desc"><p>Read text records from a network socket.</p>
<p>NOTE: tcp is nominally implemented, but DOES NOT WORK!</p>
<p>TODO: code won't handle records that are larger than 4K right now,
which, if we start getting into Toby Martin's Total Metadata Ingestion
(TMI), may not be enough. We'll need to implement something that will
aggregate recv()'s and know when it's got an entire record?</p>
<pre><code>network      Network address to read, in host:port format (e.g.
             'rvdas:6202'). If host is omitted (e.g. ':6202'),
             read via UDP on specified port.

eol          If not specified, assume one record per network packet.  If
             specified, buffer network reads until the eol
             character has been seen, and return the entire record
             at once, retaining everything after the eol for the
             start of the subsequent record. If multiple eol characters
             are encountered in a packet, split the packet and return
             the first of them, buffering the remainder for subsequent
             calls.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetworkReader(Reader):
  &#34;&#34;&#34;
  Read text records from a network socket.

  NOTE: tcp is nominally implemented, but DOES NOT WORK!

  TODO: code won&#39;t handle records that are larger than 4K right now,
  which, if we start getting into Toby Martin&#39;s Total Metadata Ingestion
  (TMI), may not be enough. We&#39;ll need to implement something that will
  aggregate recv()&#39;s and know when it&#39;s got an entire record?
  &#34;&#34;&#34;
  ############################
  def __init__(self, network, eol=None, read_buffer_size=READ_BUFFER_SIZE):
    &#34;&#34;&#34;
    ```
    network      Network address to read, in host:port format (e.g.
                 &#39;rvdas:6202&#39;). If host is omitted (e.g. &#39;:6202&#39;),
                 read via UDP on specified port.

    eol          If not specified, assume one record per network packet.  If
                 specified, buffer network reads until the eol
                 character has been seen, and return the entire record
                 at once, retaining everything after the eol for the
                 start of the subsequent record. If multiple eol characters
                 are encountered in a packet, split the packet and return
                 the first of them, buffering the remainder for subsequent
                 calls.
    ```
    &#34;&#34;&#34;
    super().__init__(output_format=Text)

    self.network = network
    self.eol = eol
    self.read_buffer_size = read_buffer_size

    # Where we&#39;ll aggregate incomplete records if an eol char is specified
    self.record_buffer = &#39;&#39;

    if network.find(&#39;:&#39;) == -1:
      raise ValueError(&#39;NetworkReader network argument must be in \&#39;host:port\&#39;&#39;
                       &#39; or \&#39;:port\&#39; format. Found &#34;%s&#34;&#39; % network)
    (host, port) = network.split(&#39;:&#39;)
    port = int(port)

    # TCP if host is specified
    if host:
      self.socket = socket.socket(family=socket.AF_INET,
                                  type=socket.SOCK_STREAM,
                                  proto=socket.IPPROTO_TCP)
      # Should this be bind()?
      self.socket.connect((host, port))

    # UDP broadcast if no host specified. Note that there&#39;s some
    # dodginess I don&#39;t understand about networks: if &#39;&lt;broadcast&gt;&#39; is
    # specified, socket tries to send on *all* interfaces. if &#39;&#39; is
    # specified, it tries to send on *any* interface.
    else:
      host = &#39;&#39; # special code for broadcast
      self.socket = socket.socket(family=socket.AF_INET,
                                  type=socket.SOCK_DGRAM,
                                  proto=socket.IPPROTO_UDP)
      self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, True)
      try: # Raspbian doesn&#39;t recognize SO_REUSEPORT
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, True)
      except AttributeError:
        logging.warning(&#39;Unable to set socket REUSEPORT; system may not support it.&#39;)
      self.socket.bind((host, port))

  ############################
  def read(self):
    &#34;&#34;&#34;
    Read the next network packet.
    &#34;&#34;&#34;
    # If no eol character/string specified, just read a packet and
    # return it as the next record.
    if not self.eol:
      record = self.socket.recv(self.read_buffer_size)
      logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
      if record:
        record = record.decode(&#39;utf-8&#39;)
      return record

    # If an eol character/string has been specified, we may have to
    # loop our reads until we see an eol.
    while True:
      eol_pos = self.record_buffer.rfind(self.eol)
      if eol_pos &gt; -1:
        logging.debug(&#39;NetworkReader found eol; returning record&#39;)

        # We have an eol string somewhere in our buffer. Extract
        # everything up to the last eol and split up by eol&#39;s.
        record_end = eol_pos + len(self.eol)
        record = self.record_buffer[0:eol_pos].split(self.eol)
        self.record_buffer = self.record_buffer[record_end:]

        # If we only have one record in list, return it as a string,
        # otherwise return as list of strings.
        if len(record) == 1:
          record = record[0]          
        return record

      # If no eol string, read, append, and try again.
      record = self.socket.recv(self.read_buffer_size)
      logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
      if record:
        self.record_buffer += record.decode(&#39;utf-8&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="logger.readers.network_reader.NetworkReader.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the next network packet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
  &#34;&#34;&#34;
  Read the next network packet.
  &#34;&#34;&#34;
  # If no eol character/string specified, just read a packet and
  # return it as the next record.
  if not self.eol:
    record = self.socket.recv(self.read_buffer_size)
    logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
    if record:
      record = record.decode(&#39;utf-8&#39;)
    return record

  # If an eol character/string has been specified, we may have to
  # loop our reads until we see an eol.
  while True:
    eol_pos = self.record_buffer.rfind(self.eol)
    if eol_pos &gt; -1:
      logging.debug(&#39;NetworkReader found eol; returning record&#39;)

      # We have an eol string somewhere in our buffer. Extract
      # everything up to the last eol and split up by eol&#39;s.
      record_end = eol_pos + len(self.eol)
      record = self.record_buffer[0:eol_pos].split(self.eol)
      self.record_buffer = self.record_buffer[record_end:]

      # If we only have one record in list, return it as a string,
      # otherwise return as list of strings.
      if len(record) == 1:
        record = record[0]          
      return record

    # If no eol string, read, append, and try again.
    record = self.socket.recv(self.read_buffer_size)
    logging.debug(&#39;NetworkReader.read() received %d bytes&#39;, len(record))
    if record:
      self.record_buffer += record.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="logger.readers.reader.Reader" href="reader.html#logger.readers.reader.Reader">Reader</a></b></code>:
<ul class="hlist">
<li><code><a title="logger.readers.reader.Reader.output_format" href="reader.html#logger.readers.reader.Reader.output_format">output_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="logger.readers" href="index.html">logger.readers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="logger.readers.network_reader.NetworkReader" href="#logger.readers.network_reader.NetworkReader">NetworkReader</a></code></h4>
<ul class="">
<li><code><a title="logger.readers.network_reader.NetworkReader.read" href="#logger.readers.network_reader.NetworkReader.read">read</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>